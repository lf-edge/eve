#!/bin/sh
#
# Copyright (c) 2024 Zededa, Inc.
# SPDX-License-Identifier: Apache-2.0

LOG_SIZE=$((5*1024*1024))
K3s_LOG_FILE="k3s.log"
SAVE_KUBE_VAR_LIB_DIR="/persist/kube-save-var-lib"

logmsg() {
        local MSG
        local TIME
        MSG="$*"
        TIME=$(date +"%F %T")
        echo "$TIME : $MSG"  >> "$INSTALL_LOG"
}

check_network_connection () {
        while true; do
                ret=$(curl -o /dev/null -w "%{http_code}" -s "https://get.k3s.io")
                if [ "$ret" -eq 200 ]; then
                        logmsg "Network is ready."
                        break;
                else
                        logmsg "Network is not yet ready"
                fi
                sleep 5
        done
}

setup_cgroup () {
        echo "cgroup /sys/fs/cgroup cgroup defaults 0 0" >> /etc/fstab
}

check_log_file_size() {
        currentSize=$(wc -c <"$K3S_LOG_DIR/$1")
        if [ "$currentSize" -gt "$LOG_SIZE" ]; then
                if [ -f "$K3S_LOG_DIR/$1.2" ]; then
                        cp -p "$K3S_LOG_DIR/$1.2" "$K3S_LOG_DIR/$1.3"
                fi
                if [ -f "$K3S_LOG_DIR/$1.1" ]; then
                        cp -p "$K3S_LOG_DIR/$1.1" "$K3S_LOG_DIR/$1.2"
                fi
                # keep the original log file's attributes
                cp -p "$K3S_LOG_DIR/$1" "$K3S_LOG_DIR/$1.1"
                # Check if the argument passed is "$K3s_LOG_FILE", sometimes the k3s is
                # not releasing the file descriptor, so truncate the file may not
                # take effect. Signal a HUP signal to that.
                if [ "$1" = "$K3s_LOG_FILE" ]; then
                        k3s_pid=$(pgrep -f "k3s server")
                        if [ -n "$k3s_pid" ]; then
                                kill -HUP "$k3s_pid"
                                logmsg "Sent HUP signal to k3s server before truncate k3s.log size"
                        fi
                fi
                truncate -s 0 "$K3S_LOG_DIR/$1"
                logmsg "k3s logfile $1, size $currentSize rotate"
        fi
}

# search and find the last occurrence of the k3s staring string in the file
# and gzip the content from that line to the end of the file
# do the entire file if the string is not found
gzip_last_restart_part() {
    fileBaseName=$1
    targetFile=$2
    searchString="Starting k3s $K3S_VERSION"

    # Find the line number of the last occurrence of the search string, or 1 if not found
    lastLine=$(grep -n -F "$searchString" "$fileBaseName" | tail -n 1 | cut -d: -f1)
    lastLine=${lastLine:-1}

    # Extract the content from the last occurrence of the search string to the end
    tail -n +"$lastLine" "$fileBaseName" | gzip -k -9 -c > "$targetFile"
}

save_crash_log() {
        if [ "$RESTART_COUNT" = "1" ]; then
                return
        fi

        # add timestamp to the filename for clear identification
        timestamp=$(date +"%Y%m%d-%H%M%S")
        # This pattern will alias with older crashes, but also a simple way to contain log bloat
        crashLogBaseName="${K3s_LOG_FILE}.restart.${timestamp}.${RESTART_COUNT}.gz"

        gzip_last_restart_part "${K3S_LOG_DIR}/${K3s_LOG_FILE}" "${K3S_LOG_DIR}/${crashLogBaseName}"

        # Find and list files matching the pattern
        matching_files=""
        for file in "$K3S_LOG_DIR"/*; do
                if echo "$file" | grep -q "${K3s_LOG_FILE}.restart.*.gz"; then
                        matching_files="$matching_files $file"
                fi
        done
        matching_files=$(echo "$matching_files" | xargs)
        file_count=$(echo "$matching_files" | wc -w)

        logmsg "total $file_count crash logs found in dir $K3S_LOG_DIR, file prefix $K3s_LOG_FILE"
        if [ "$file_count" -gt 10 ]; then
                files_to_delete=$(find "$K3S_LOG_DIR" -type f -name "${K3s_LOG_FILE}.restart.*.gz" -print0 | xargs -0 ls -t | tail -n +11)
                echo "$files_to_delete" | while read -r file; do
                        rm -f "${K3S_LOG_DIR}/${file}"
                done
        fi
}

# k3s can generate log files such as this: k3s-2024-07-30T20-29-31.172.log.gz
# they seem to be generated by raft operation warnings
# this check and remove is to prevent the log files from growing indefinitely
# keep the latest 10 log files and delete the rest
check_and_remove_excessive_k3s_logs() {

    # Directory to search in (current directory in this case)
    search_dir="$K3S_LOG_DIR"

    # Regular expression pattern for date and time in the format YYYY-MM-DDTHH-MM-SS.mmm
    pattern='k3s-[0-9]{4}-[0-9]{2}-[0-9]{2}T[0-9]{2}-[0-9]{2}-[0-9]{2}\.[0-9]{3}\.log\.gz'

    # Find and list files matching the pattern
    matching_files=$(find "$search_dir" -type f -name 'k3s-*.log.gz' | grep -E "$pattern")
    file_count=$(echo "$matching_files" | wc -w)
    if [ "$file_count" -gt 10 ]; then
        files_to_delete=$(echo "$matching_files" | grep ".log.gz" | tail -n +11)
        echo "$files_to_delete" | while read -r file; do
                rm -f "${K3S_LOG_DIR}/${file}"
        done
    fi
}

# kubernetes's name must be lower case and '-' instead of '_'
convert_to_k8s_compatible() {
        echo "$1" | tr '[:upper:]_' '[:lower:]-'
}

# Function to check if a string is a valid UUID
is_valid_uuid() {
    local uuid="$1"
    if echo "$uuid" | grep -qE '^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$'; then
        return 0 # Valid UUID
    else
        return 1 # Invalid UUID
    fi
}

remove_server_tls_dir() {
  if [ -d /var/lib/rancher/k3s/server/tls ]; then
    rm /var/lib/rancher/k3s/server/tls/request-header-ca.key
    rm /var/lib/rancher/k3s/server/tls/server-ca.key
    rm /var/lib/rancher/k3s/server/tls/etcd/peer-ca.key
    rm /var/lib/rancher/k3s/server/tls/etcd/server-ca.crt
    rm /var/lib/rancher/k3s/server/tls/request-header-ca.crt
    rm /var/lib/rancher/k3s/server/tls/etcd/server-ca.key
    rm /var/lib/rancher/k3s/server/cred/ipsec.psk
    rm /var/lib/rancher/k3s/server/tls/server-ca.crt
    rm /var/lib/rancher/k3s/server/tls/service.key
    rm /var/lib/rancher/k3s/server/tls/client-ca.crt
    rm /var/lib/rancher/k3s/server/tls/client-ca.key
    rm /var/lib/rancher/k3s/server/tls/etcd/peer-ca.crt
  fi
}

remove_multus_cni() {
        kubectl delete -f /etc/multus-daemonset-new.yaml
        rm /etc/multus-daemonset-new.yaml
        rm /var/lib/multus_initialized
}

# save the /var/lib to /persist/kube-save-var-lib
save_var_lib() {
  local dest_dir="${SAVE_KUBE_VAR_LIB_DIR}"
  # Check if destination directory exists, if not create it
  if [ ! -d "$dest_dir" ]; then
    mkdir -p "$dest_dir"
  fi

  # Remove everything in the destination directory
  rm -rf "${dest_dir:?}"/*

  # Copy all contents from /var/lib to destination directory
  cp -a /var/lib/. "$dest_dir"
}

# Function to restore contents from /persist/kube-save-var-lib back to /var/lib
restore_var_lib() {
  local source_dir="${SAVE_KUBE_VAR_LIB_DIR}"
  # Remove everything under /var/lib
  rm -rf /var/lib/*

  # Copy everything from /persist/kube-save-var-lib back to /var/lib
  if [ -d "$source_dir" ]; then
        cp -a "${source_dir}/." /var/lib
  else
        ## the saved files are missing, have do install again
        Update_CheckNodeComponents
  fi
}

# when transitioning from single node to cluster mode, the k3s.yaml file may need
# to change with new certificates
check_kubeconfig_yaml_files() {
    file1="/etc/rancher/k3s/k3s.yaml"
    file2="/run/.kube/k3s/k3s.yaml"

    if ! cmp -s "$file1" "$file2"; then
        logmsg "k3s.yaml files are different, copying $file1 to $file2"
        cp "$file1" "$file2"
    fi
}

# get the OS-IMAGE name from the /run/eve-release
get_eve_os_release() {
        # Wait for /run/eve-release to appear
        while [ ! -f /run/eve-release ]; do
                sleep 1
        done

        # Read the original name from /run/eve-release
        eve_image_name=$(cat /run/eve-release)

        logmsg "EVE Release: $eve_image_name, write to /etc/os-release"
        # Write the short name to /etc/os-release
        echo "PRETTY_NAME=\"$eve_image_name\"" > /etc/os-release
}

terminate_k3s() {
  # Find the process ID of 'k3s server'
  pid=$(pgrep -f 'k3s server')

  # If the process exists, kill it
  if [ -n "$pid" ]; then
    logmsg "Killing 'k3s server' process with PID: $pid"
    kill "$pid"
  else
    logmsg "'k3s server' process not found"
  fi
}

# wait for debugging flag in /persist/k3s/wait_{flagname} if exist
wait_for_item() {
        filename="/persist/k3s/wait_$1"
        processname="k3s server"
        while [ -e "$filename" ]; do
                k3sproc=""
                if pgrep -x "$processname" > /dev/null; then
                        k3sproc="k3s server is running"
                else
                        k3sproc="k3s server is NOT running"
                fi
                logmsg "Found $filename file. $k3sproc, Waiting for 60 seconds..."
                sleep 60
        done
}

wait_for_device_name() {
        logmsg "Waiting for DeviceName from controller..."
        EdgeNodeInfoPath="/persist/status/zedagent/EdgeNodeInfo/global.json"
        while [ ! -f $EdgeNodeInfoPath ]; do
                sleep 5
        done
        dName=$(jq -r '.DeviceName' $EdgeNodeInfoPath)
        if [ -n "$dName" ]; then
                HOSTNAME=$(convert_to_k8s_compatible "$dName")
        fi

        # we should have the uuid since we got the device name
        while true; do
                DEVUUID=$(/bin/hostname)
                if is_valid_uuid "$DEVUUID"; then
                        logmsg "got valid Device UUID: $DEVUUID"
                        break
                else
                        sleep 5
                fi
        done

        if ! grep -q node-name /etc/rancher/k3s/config.yaml; then
                echo "node-name: $HOSTNAME" >> /etc/rancher/k3s/config.yaml
        fi
        logmsg "Hostname: $HOSTNAME"
}

wait_for_default_route() {
        while read -r iface dest gw flags refcnt use metric mask mtu window irtt; do
                if [ "$dest" = "00000000" ] && [ "$mask" = "00000000" ]; then
                        logmsg "Default route found"
                        return 0
                fi
                logmsg "waiting for default route $iface $dest $gw $flags $refcnt $use $metric $mask $mtu $window $irtt"
                sleep 1
        done < /proc/net/route
        return 1
}
