// Copyright (c) 2023 Zededa, Inc.
// SPDX-License-Identifier: Apache-2.0

// Utility used by wwan-init.sh script to decrypt user password(s) encrypted
// by NIM inside /run/wwan/config.json

package main

import (
	"crypto/aes"
	"crypto/cipher"
	"crypto/sha256"
	"encoding/base64"
	"fmt"
	"os"
	"strings"

	"golang.org/x/crypto/pbkdf2"
)

const (
	// File with random ID that is regenerated by the kernel on each boot.
	// Used as a passphrase to encrypt cellular network password before publishing
	// from NIM to the wwan microservice.
	bootIDFile      = "/proc/sys/kernel/random/boot_id"
	saltSize        = 16
	ivSize          = 12
	pbkdf2IterCount = 4096
)

// Decrypt user password encrypted by NIM using AES-256-GCM with the key derived
// by the PBKDF2 method, taking kernel-generated /proc/sys/kernel/random/boot_id
// as the input.
// The decryption algorithm and its parameters used here should align with the encryption
// algorithm executed by LinuxDpcReconciler (package pkg/pillar/dpcreconciler),
// method encryptCellularPassword.
func decryptPassword(ciphertext string) (password string, err error) {
	cipherbytes, err := base64.StdEncoding.DecodeString(ciphertext)
	if err != nil {
		return "", err
	}
	if len(cipherbytes) < saltSize+ivSize {
		return "", fmt.Errorf("ciphertext too short")
	}
	salt := cipherbytes[:saltSize]
	iv := cipherbytes[saltSize : saltSize+ivSize]
	cipherbytes = cipherbytes[saltSize+ivSize:]
	bootID, err := os.ReadFile(bootIDFile)
	if err != nil {
		return "", err
	}
	passphrase := strings.TrimSpace(string(bootID))
	// AES-256 uses a 32-byte key.
	key := pbkdf2.Key([]byte(passphrase), salt, pbkdf2IterCount, 32, sha256.New)
	block, err := aes.NewCipher(key)
	if err != nil {
		return "", err
	}
	gcm, err := cipher.NewGCMWithNonceSize(block, ivSize)
	if err != nil {
		return "", err
	}
	plaintext, err := gcm.Open(nil, iv, cipherbytes, nil)
	if err != nil {
		return "", err
	}
	return string(plaintext), nil
}

func main() {
	if len(os.Args) < 2 {
		fmt.Fprintf(os.Stderr, "Usage: %s <ciphertext>\n", os.Args[0])
		os.Exit(1)
	}
	ciphertext := os.Args[1]
	password, err := decryptPassword(ciphertext)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Failed to decrypt password: %v\n", err)
		os.Exit(1)
	}
	fmt.Print(password)
}
