package hypervisor

import (
	"bytes"
	"fmt"
	"net"
	"os"
	"os/exec"
	"regexp"
	"testing"

	"github.com/google/go-cmp/cmp"
	zconfig "github.com/lf-edge/eve-api/go/config"
	"github.com/lf-edge/eve/pkg/pillar/types"
	. "github.com/onsi/gomega"
	uuid "github.com/satori/go.uuid"
)

const (
	// DefaultUUID is the default UUID for the domain
	DefaultUUID = "e4f1c2a7-9b3d-4e5f-8a6b-2c7d9e0f1a2b"
	// DefaultDomainName is the default domain name
	DefaultDomainName = DefaultUUID + ".0.0"
)

var kvmIntel, kvmArm KvmContext
var swtpmCtrlSock = ""

// these ones are very much handcrafted just for the tests
func init() {
	kvmIntel = KvmContext{
		devicemodel: "pc-q35-3.1",
		dmExec:      "",
		dmArgs:      []string{},
	}
	kvmArm = KvmContext{
		devicemodel: "virt",
		dmExec:      "",
		dmArgs:      []string{},
	}
}

// setStaticVsockCid is a helper function to set the guest-cid to a static value
// in the resulting config file otherwise the test will fail because the guest-cid
// is incremented every time config file is generated.
func setStaticVsockCid(input []byte) []byte {
	re := regexp.MustCompile(`guest-cid\s*=\s*"\d+"`)
	out := re.ReplaceAllString(string(input), `guest-cid = "3"`)
	return []byte(out)
}

func TestCreateDomConfigOnlyCom1(t *testing.T) {
	id, err := uuid.NewV4()
	if err != nil {
		t.Errorf("NewV4 failed: %v", err)
	}
	config := types.DomainConfig{
		UUIDandVersion: types.UUIDandVersion{UUID: id, Version: "1.0"},
		VmConfig: types.VmConfig{
			Kernel:     "/boot/kernel",
			Ramdisk:    "/boot/ramdisk",
			ExtraArgs:  "init=/bin/sh",
			Memory:     1024 * 1024 * 10,
			VCpus:      2,
			VncDisplay: 5,
			VncPasswd:  "rosebud",
		},
		GPUConfig: "legacy",
		VifList: []types.VifConfig{
			{Bridge: "bn0", Mac: net.HardwareAddr{0x6a, 0x00, 0x03, 0x61, 0xa6, 0x90}, Vif: "nbu1x1"},
			{Bridge: "bn0", Mac: net.HardwareAddr{0x6a, 0x00, 0x03, 0x61, 0xa6, 0x91}, Vif: "nbu1x2"},
		},
		IoAdapterList: []types.IoAdapter{
			{Type: types.IoCom, Name: "COM1"},
		},
	}
	disks := []types.DiskStatus{
		{Format: zconfig.Format_QCOW2, FileLocation: "/foo/bar.qcow2", Devtype: "hdd"},
		{Format: zconfig.Format_CONTAINER, FileLocation: "/foo/container", Devtype: "9P"},
		{Format: zconfig.Format_RAW, FileLocation: "/foo/bar.raw", Devtype: "hdd"},
		{Format: zconfig.Format_RAW, FileLocation: "/foo/cd.iso", Devtype: "cdrom"},
		{Format: zconfig.Format_CONTAINER, FileLocation: "/foo/volume", Devtype: ""},
	}
	aa := types.AssignableAdapters{
		Initialized: true,
		IoBundleList: []types.IoBundle{
			{
				Type:            types.IoCom,
				AssignmentGroup: "COM1",
				Phylabel:        "COM1",
				Ifname:          "COM1",
				Serial:          "/dev/ttyS0",
				UsedByUUID:      config.UUIDandVersion.UUID,
			},
		},
	}
	conf, err := os.CreateTemp("/tmp", "config")
	if err != nil {
		t.Errorf("Can't create config file for a domain %v", err)
	} else {
		defer os.Remove(conf.Name())
	}

	t.Run("amd64", func(t *testing.T) {
		conf.Seek(0, 0)
		if err := kvmIntel.CreateDomConfig(DefaultDomainName, config, types.DomainStatus{},
			disks, &aa, nil, swtpmCtrlSock, conf); err != nil {
			t.Errorf("CreateDomConfig failed %v", err)
		}
		defer os.Truncate(conf.Name(), 0)

		result, err := os.ReadFile(conf.Name())
		if err != nil {
			t.Errorf("reading conf file failed %v", err)
		}

		// this is the only way to get the expected output (◔_◔)
		result = setStaticVsockCid(result)
		expected := fmt.Sprintf(`# This file is automatically generated by domainmgr
[msg]
  timestamp = "on"

[machine]
  type = "pc-q35-3.1"
  dump-guest-core = "off"
  accel = "kvm"
  vmport = "off"
  kernel-irqchip = "on"
  kernel = "/boot/kernel"
  initrd = "/boot/ramdisk"
  append = "init=/bin/sh"

[global]
  driver = "kvm-pit"
  property = "lost_tick_policy"
  value = "delay"

[global]
  driver = "ICH9-LPC"
  property = "disable_s3"
  value = "1"

[global]
  driver = "ICH9-LPC"
  property = "disable_s4"
  value = "1"

[rtc]
  base = "localtime"
  driftfix = "slew"

[device]
  driver = "intel-iommu"
  caching-mode = "on"

[overcommit]
  mem-lock = "off"

[chardev "charmonitor"]
  backend = "socket"
  path = "/run/hypervisor/kvm/%s/qmp"
  server = "on"
  wait = "off"

[mon "monitor"]
  chardev = "charmonitor"
  mode = "control"

[chardev "charlistener"]
  backend = "socket"
  path = "/run/hypervisor/kvm/%s/listener.qmp"
  server = "on"
  wait = "off"

[mon "listener"]
  chardev = "charlistener"
  mode = "control"

[memory]
  size = "10240"

[smp-opts]
  cpus = "2"
  sockets = "1"
  cores = "2"
  threads = "1"

[device]
  driver = "virtio-serial"
  addr = "3"

[chardev "charserial0"]
  backend = "socket"
  mux = "on"
  path = "/run/hypervisor/kvm/%s/cons"
  server = "on"
  wait = "off"
  logfile = "/dev/fd/1"
  logappend = "on"

[device]
  driver = "virtconsole"
  chardev = "charserial0"
  name = "org.lfedge.eve.console.0"



#[device "video0"]
#  driver = "qxl-vga"
#  ram_size = "67108864"
#  vram_size = "67108864"
#  vram64_size_mb = "0"
#  vgamem_mb = "16"
#  max_outputs = "1"
#  bus = "pcie.0"
#  addr = "0x1"

[device "video0"]
  driver = "VGA"
  vgamem_mb = "16"
  bus = "pcie.0"
  addr = "0x1"

[device "pci.2"]
  driver = "pcie-root-port"
  port = "12"
  chassis = "2"
  bus = "pcie.0"
  addr = "0x2"

[device "usb"]
  driver = "qemu-xhci"
  p2 = "15"
  p3 = "15"
  bus = "pci.2"
  addr = "0x0"

[device "input0"]
  driver = "usb-tablet"
  bus = "usb.0"
  port = "1"


[device "pci.4"]
  driver = "pcie-root-port"
  port = "14"
  chassis = "4"
  bus = "pcie.0"
  addr = "0x4"

[drive "drive-virtio-disk0"]
  file = "/foo/bar.qcow2"
  format = "qcow2"
  aio = "io_uring"
  cache = "writeback"
  if = "none"

[device "virtio-disk0"]
  driver = "virtio-blk-pci"
  scsi = "off"
  bus = "pci.4"
  addr = "0x0"
  drive = "drive-virtio-disk0"


[fsdev "fsdev1"]
  fsdriver = "local"
  security_model = "none"
  multidevs = "remap"
  path = "/foo/container"

[device "fs1"]
  driver = "virtio-9p-pci"
  fsdev = "fsdev1"
  mount_tag = "share_dir"
  addr = "0x5"


[device "pci.6"]
  driver = "pcie-root-port"
  port = "16"
  chassis = "6"
  bus = "pcie.0"
  addr = "0x6"

[drive "drive-virtio-disk2"]
  file = "/foo/bar.raw"
  format = "raw"
  aio = "io_uring"
  cache = "writeback"
  if = "none"

[device "virtio-disk2"]
  driver = "virtio-blk-pci"
  scsi = "off"
  bus = "pci.6"
  addr = "0x0"
  drive = "drive-virtio-disk2"


[drive "drive-sata0-3"]
  file = "/foo/cd.iso"
  format = "raw"
  if = "none"
  media = "cdrom"
  readonly = "on"

[device "sata0-0"]
  drive = "drive-sata0-3"
  driver = "ide-cd"
  bus = "ide.0"

[device "pci.7"]
  driver = "pcie-root-port"
  port = "17"
  chassis = "7"
  bus = "pcie.0"
  multifunction = "on"
  addr = "0x7"

[netdev "hostnet0"]
  type = "tap"
  ifname = "nbu1x1"
  br = "bn0"
  script = "/etc/xen/scripts/qemu-ifup"
  downscript = "no"
  vhost = "on"

[device "net0"]
  driver = "virtio-net-pci"
  netdev = "hostnet0"
  mac = "6a:00:03:61:a6:90"
  bus = "pci.7"
  addr = "0x0"

[device "pci.8"]
  driver = "pcie-root-port"
  port = "18"
  chassis = "8"
  bus = "pcie.0"
  multifunction = "on"
  addr = "0x8"

[netdev "hostnet1"]
  type = "tap"
  ifname = "nbu1x2"
  br = "bn0"
  script = "/etc/xen/scripts/qemu-ifup"
  downscript = "no"
  vhost = "on"

[device "net1"]
  driver = "virtio-net-pci"
  netdev = "hostnet1"
  mac = "6a:00:03:61:a6:91"
  bus = "pci.8"
  addr = "0x0"

[chardev "charserial-usr0"]
  backend = "serial"
  path = "/dev/ttyS0"

[device "serial-usr0"]
  driver = "isa-serial"
  chardev = "charserial-usr0"

[device "eve-vsock0"]
  driver = "vhost-vsock-pci"
  disable-legacy = "on"
  guest-cid = "3"
`, DefaultDomainName, DefaultDomainName, DefaultDomainName)
		if string(result) != expected {
			t.Errorf("got an unexpected resulting config %s", string(result))
		}
	})

	config.VirtualizationMode = types.FML
	config.BootLoader = "/usr/lib/xen/boot/OVMF_CODE.fd"
	t.Run("amd64-fml", func(t *testing.T) {
		conf.Seek(0, 0)
		if err := kvmIntel.CreateDomConfig(DefaultDomainName, config, types.DomainStatus{},
			disks, &aa, nil, swtpmCtrlSock, conf); err != nil {
			t.Errorf("CreateDomConfig failed %v", err)
		}
		defer os.Truncate(conf.Name(), 0)

		result, err := os.ReadFile(conf.Name())
		if err != nil {
			t.Errorf("reading conf file failed %v", err)
		}

		result = setStaticVsockCid(result)
		expected := fmt.Sprintf(`# This file is automatically generated by domainmgr
[msg]
  timestamp = "on"

[machine]
  type = "pc-q35-3.1"
  dump-guest-core = "off"
  accel = "kvm"
  vmport = "off"
  kernel-irqchip = "on"
  kernel = "/boot/kernel"
  initrd = "/boot/ramdisk"
  append = "init=/bin/sh"

[global]
  driver = "kvm-pit"
  property = "lost_tick_policy"
  value = "delay"

[global]
  driver = "ICH9-LPC"
  property = "disable_s3"
  value = "1"

[global]
  driver = "ICH9-LPC"
  property = "disable_s4"
  value = "1"

[rtc]
  base = "localtime"
  driftfix = "slew"

[device]
  driver = "intel-iommu"
  caching-mode = "on"

[drive "drive-ovmf-code"]
  if = "pflash"
  format = "raw"
  readonly = "on"
  unit = "0"
  file = "/usr/lib/xen/boot/OVMF_CODE.fd"

[drive "drive-ovmf-vars"]
  if = "pflash"
  format = "raw"
  unit = "1"
  file = "/persist/vault/ovmf/%s_OVMF_VARS.fd"

[overcommit]
  mem-lock = "off"

[chardev "charmonitor"]
  backend = "socket"
  path = "/run/hypervisor/kvm/%s/qmp"
  server = "on"
  wait = "off"

[mon "monitor"]
  chardev = "charmonitor"
  mode = "control"

[chardev "charlistener"]
  backend = "socket"
  path = "/run/hypervisor/kvm/%s/listener.qmp"
  server = "on"
  wait = "off"

[mon "listener"]
  chardev = "charlistener"
  mode = "control"

[memory]
  size = "10240"

[smp-opts]
  cpus = "2"
  sockets = "1"
  cores = "2"
  threads = "1"

[device]
  driver = "virtio-serial"
  addr = "3"

[chardev "charserial0"]
  backend = "socket"
  mux = "on"
  path = "/run/hypervisor/kvm/%s/cons"
  server = "on"
  wait = "off"
  logfile = "/dev/fd/1"
  logappend = "on"

[device]
  driver = "virtconsole"
  chardev = "charserial0"
  name = "org.lfedge.eve.console.0"



#[device "video0"]
#  driver = "qxl-vga"
#  ram_size = "67108864"
#  vram_size = "67108864"
#  vram64_size_mb = "0"
#  vgamem_mb = "16"
#  max_outputs = "1"
#  bus = "pcie.0"
#  addr = "0x1"

[device "video0"]
  driver = "VGA"
  vgamem_mb = "16"
  bus = "pcie.0"
  addr = "0x1"

[device "pci.2"]
  driver = "pcie-root-port"
  port = "12"
  chassis = "2"
  bus = "pcie.0"
  addr = "0x2"

[device "usb"]
  driver = "qemu-xhci"
  p2 = "15"
  p3 = "15"
  bus = "pci.2"
  addr = "0x0"

[device "input0"]
  driver = "usb-tablet"
  bus = "usb.0"
  port = "1"


[device "pci.4"]
  driver = "pcie-root-port"
  port = "14"
  chassis = "4"
  bus = "pcie.0"
  addr = "0x4"

[drive "drive-virtio-disk0"]
  file = "/foo/bar.qcow2"
  format = "qcow2"
  aio = "io_uring"
  cache = "writeback"
  if = "none"

[device "virtio-disk0"]
  driver = "virtio-blk-pci"
  scsi = "off"
  bus = "pci.4"
  addr = "0x0"
  drive = "drive-virtio-disk0"


[fsdev "fsdev1"]
  fsdriver = "local"
  security_model = "none"
  multidevs = "remap"
  path = "/foo/container"

[device "fs1"]
  driver = "virtio-9p-pci"
  fsdev = "fsdev1"
  mount_tag = "share_dir"
  addr = "0x5"


[device "pci.6"]
  driver = "pcie-root-port"
  port = "16"
  chassis = "6"
  bus = "pcie.0"
  addr = "0x6"

[drive "drive-virtio-disk2"]
  file = "/foo/bar.raw"
  format = "raw"
  aio = "io_uring"
  cache = "writeback"
  if = "none"

[device "virtio-disk2"]
  driver = "virtio-blk-pci"
  scsi = "off"
  bus = "pci.6"
  addr = "0x0"
  drive = "drive-virtio-disk2"


[drive "drive-sata0-3"]
  file = "/foo/cd.iso"
  format = "raw"
  if = "none"
  media = "cdrom"
  readonly = "on"

[device "sata0-0"]
  drive = "drive-sata0-3"
  driver = "ide-cd"
  bus = "ide.0"

[device "pci.7"]
  driver = "pcie-root-port"
  port = "17"
  chassis = "7"
  bus = "pcie.0"
  multifunction = "on"
  addr = "0x7"

[netdev "hostnet0"]
  type = "tap"
  ifname = "nbu1x1"
  br = "bn0"
  script = "/etc/xen/scripts/qemu-ifup"
  downscript = "no"
  vhost = "on"

[device "net0"]
  driver = "virtio-net-pci"
  netdev = "hostnet0"
  mac = "6a:00:03:61:a6:90"
  bus = "pci.7"
  addr = "0x0"

[device "pci.8"]
  driver = "pcie-root-port"
  port = "18"
  chassis = "8"
  bus = "pcie.0"
  multifunction = "on"
  addr = "0x8"

[netdev "hostnet1"]
  type = "tap"
  ifname = "nbu1x2"
  br = "bn0"
  script = "/etc/xen/scripts/qemu-ifup"
  downscript = "no"
  vhost = "on"

[device "net1"]
  driver = "virtio-net-pci"
  netdev = "hostnet1"
  mac = "6a:00:03:61:a6:91"
  bus = "pci.8"
  addr = "0x0"

[chardev "charserial-usr0"]
  backend = "serial"
  path = "/dev/ttyS0"

[device "serial-usr0"]
  driver = "isa-serial"
  chardev = "charserial-usr0"

[device "eve-vsock0"]
  driver = "vhost-vsock-pci"
  disable-legacy = "on"
  guest-cid = "3"
`, DefaultUUID, DefaultDomainName, DefaultDomainName, DefaultDomainName)
		if string(result) != expected {
			t.Errorf("got an unexpected resulting config %s", string(result))
		}
	})

	config.VirtualizationMode = types.HVM
	config.BootLoader = "/usr/lib/xen/boot/ovmf.bin"
	t.Run("arm64", func(t *testing.T) {
		conf.Seek(0, 0)
		if err := kvmArm.CreateDomConfig(DefaultDomainName, config, types.DomainStatus{},
			disks, &aa, nil, swtpmCtrlSock, conf); err != nil {
			t.Errorf("CreateDomConfig failed %v", err)
		}
		defer os.Truncate(conf.Name(), 0)

		result, err := os.ReadFile(conf.Name())
		if err != nil {
			t.Errorf("reading conf file failed %v", err)
		}

		result = setStaticVsockCid(result)
		expected := fmt.Sprintf(`# This file is automatically generated by domainmgr
[msg]
  timestamp = "on"

[machine]
  type = "virt"
  dump-guest-core = "off"
  accel = "kvm:tcg"
  gic-version = "host"
  firmware = "/usr/lib/xen/boot/ovmf.bin"
  kernel = "/boot/kernel"
  initrd = "/boot/ramdisk"
  append = "init=/bin/sh"


[overcommit]
  mem-lock = "off"

[chardev "charmonitor"]
  backend = "socket"
  path = "/run/hypervisor/kvm/%s/qmp"
  server = "on"
  wait = "off"

[mon "monitor"]
  chardev = "charmonitor"
  mode = "control"

[chardev "charlistener"]
  backend = "socket"
  path = "/run/hypervisor/kvm/%s/listener.qmp"
  server = "on"
  wait = "off"

[mon "listener"]
  chardev = "charlistener"
  mode = "control"

[memory]
  size = "10240"

[smp-opts]
  cpus = "2"
  sockets = "1"
  cores = "2"
  threads = "1"

[device]
  driver = "virtio-serial"
  addr = "3"

[chardev "charserial0"]
  backend = "socket"
  mux = "on"
  path = "/run/hypervisor/kvm/%s/cons"
  server = "on"
  wait = "off"
  logfile = "/dev/fd/1"
  logappend = "on"

[device]
  driver = "virtconsole"
  chardev = "charserial0"
  name = "org.lfedge.eve.console.0"



#[device "video0"]
#  driver = "qxl-vga"
#  ram_size = "67108864"
#  vram_size = "67108864"
#  vram64_size_mb = "0"
#  vgamem_mb = "16"
#  max_outputs = "1"
#  bus = "pcie.0"
#  addr = "0x1"

[device "video0"]
  driver = "virtio-gpu-pci"

[device "pci.2"]
  driver = "pcie-root-port"
  port = "12"
  chassis = "2"
  bus = "pcie.0"
  addr = "0x2"

[device "usb"]
  driver = "qemu-xhci"
  p2 = "15"
  p3 = "15"
  bus = "pci.2"
  addr = "0x0"

[device "input0"]
  driver = "usb-kbd"
  bus = "usb.0"
  port = "1"

[device "input1"]
  driver = "usb-mouse"
  bus = "usb.0"
  port = "2"


[device "pci.4"]
  driver = "pcie-root-port"
  port = "14"
  chassis = "4"
  bus = "pcie.0"
  addr = "0x4"

[drive "drive-virtio-disk0"]
  file = "/foo/bar.qcow2"
  format = "qcow2"
  aio = "io_uring"
  cache = "writeback"
  if = "none"

[device "virtio-disk0"]
  driver = "virtio-blk-pci"
  scsi = "off"
  bus = "pci.4"
  addr = "0x0"
  drive = "drive-virtio-disk0"


[fsdev "fsdev1"]
  fsdriver = "local"
  security_model = "none"
  multidevs = "remap"
  path = "/foo/container"

[device "fs1"]
  driver = "virtio-9p-pci"
  fsdev = "fsdev1"
  mount_tag = "share_dir"
  addr = "0x5"


[device "pci.6"]
  driver = "pcie-root-port"
  port = "16"
  chassis = "6"
  bus = "pcie.0"
  addr = "0x6"

[drive "drive-virtio-disk2"]
  file = "/foo/bar.raw"
  format = "raw"
  aio = "io_uring"
  cache = "writeback"
  if = "none"

[device "virtio-disk2"]
  driver = "virtio-blk-pci"
  scsi = "off"
  bus = "pci.6"
  addr = "0x0"
  drive = "drive-virtio-disk2"


[drive "drive-sata0-3"]
  file = "/foo/cd.iso"
  format = "raw"
  if = "none"
  media = "cdrom"
  readonly = "on"

[device "sata0-0"]
  drive = "drive-sata0-3"
  driver = "usb-storage"


[device "pci.7"]
  driver = "pcie-root-port"
  port = "17"
  chassis = "7"
  bus = "pcie.0"
  multifunction = "on"
  addr = "0x7"

[netdev "hostnet0"]
  type = "tap"
  ifname = "nbu1x1"
  br = "bn0"
  script = "/etc/xen/scripts/qemu-ifup"
  downscript = "no"
  vhost = "on"

[device "net0"]
  driver = "virtio-net-pci"
  netdev = "hostnet0"
  mac = "6a:00:03:61:a6:90"
  bus = "pci.7"
  addr = "0x0"

[device "pci.8"]
  driver = "pcie-root-port"
  port = "18"
  chassis = "8"
  bus = "pcie.0"
  multifunction = "on"
  addr = "0x8"

[netdev "hostnet1"]
  type = "tap"
  ifname = "nbu1x2"
  br = "bn0"
  script = "/etc/xen/scripts/qemu-ifup"
  downscript = "no"
  vhost = "on"

[device "net1"]
  driver = "virtio-net-pci"
  netdev = "hostnet1"
  mac = "6a:00:03:61:a6:91"
  bus = "pci.8"
  addr = "0x0"

[chardev "charserial-usr0"]
  backend = "serial"
  path = "/dev/ttyS0"

[device "serial-usr0"]
  driver = "pci-serial"
  chardev = "charserial-usr0"

[device "eve-vsock0"]
  driver = "vhost-vsock-pci"
  disable-legacy = "on"
  guest-cid = "3"
`, DefaultDomainName, DefaultDomainName, DefaultDomainName)
		if string(result) != expected {
			t.Errorf("got an unexpected resulting config %s", string(result))
		}
	})
}

func TestCreateDomConfigAmd64(t *testing.T) {
	t.Parallel()

	conf, err := os.CreateTemp("/tmp", "config")
	if err != nil {
		t.Errorf("Can't create config file for a domain %v", err)
	}
	defer os.Remove(conf.Name())

	diskConfigs, diskStatuses := qemuDisks()
	config, aa := domainConfigAndAssignableAdapters(diskConfigs)
	if err := kvmIntel.CreateDomConfig(DefaultDomainName, config, types.DomainStatus{},
		diskStatuses, &aa, nil, swtpmCtrlSock, conf); err != nil {
		t.Errorf("CreateDomConfig failed %v", err)
	}
	defer os.Truncate(conf.Name(), 0)

	result, err := os.ReadFile(conf.Name())
	if err != nil {
		t.Errorf("reading conf file failed %v", err)
	}

	result = setStaticVsockCid(result)
	if string(result) != domConfigAmd64() {
		t.Errorf("got an unexpected resulting config %s", string(result))
	}
}

func TestCreateDomConfigAmd64Legacy(t *testing.T) {
	t.Parallel()

	conf, err := os.CreateTemp("/tmp", "config")
	if err != nil {
		t.Errorf("Can't create config file for a domain %v", err)
	}
	defer os.Remove(conf.Name())
	diskCondigsLegacy, diskStatusesLegacy := qemuDisksLegacy()
	config, aa := domainConfigAndAssignableAdapters(diskCondigsLegacy)
	config.VirtualizationMode = types.LEGACY
	if err := kvmIntel.CreateDomConfig(DefaultDomainName, config, types.DomainStatus{},
		diskStatusesLegacy, &aa, nil, swtpmCtrlSock, conf); err != nil {
		t.Errorf("CreateDomConfig failed %v", err)
	}
	defer os.Truncate(conf.Name(), 0)

	result, err := os.ReadFile(conf.Name())
	if err != nil {
		t.Errorf("reading conf file failed %v", err)
	}

	result = setStaticVsockCid(result)
	if string(result) != domConfigAmd64Legacy() {
		t.Errorf("got an unexpected resulting config %s", string(result))
	}
}
func TestCreateDomConfigAmd64Fml(t *testing.T) {
	t.Parallel()

	conf, err := os.CreateTemp("/tmp", "config")
	if err != nil {
		t.Errorf("Can't create config file for a domain %v", err)
	}
	defer os.Remove(conf.Name())
	diskConfigs, diskStatuses := qemuDisks()
	config, aa := domainConfigAndAssignableAdapters(diskConfigs)
	config.VirtualizationMode = types.FML
	config.BootLoader = "/usr/lib/xen/boot/OVMF_CODE.fd"
	addNonExistingAdapter(&config, &aa)
	if err := kvmIntel.CreateDomConfig(DefaultDomainName, config, types.DomainStatus{},
		diskStatuses, &aa, nil, swtpmCtrlSock, conf); err != nil {
		t.Errorf("CreateDomConfig failed %v", err)
	}
	aa.IoBundleList = aa.IoBundleList[:len(aa.IoBundleList)-1]
	config.IoAdapterList = config.IoAdapterList[:len(config.IoAdapterList)-1]
	defer os.Truncate(conf.Name(), 0)

	result, err := os.ReadFile(conf.Name())
	if err != nil {
		t.Errorf("reading conf file failed %v", err)
	}

	result = setStaticVsockCid(result)
	if string(result) != domConfigAmd64FML() {
		t.Errorf("got an unexpected resulting config %s", cmp.Diff(string(result), domConfigAmd64FML()))
	}
}

func TestCreateDomConfigArm64(t *testing.T) {
	t.Parallel()

	conf, err := os.CreateTemp("/tmp", "config")
	if err != nil {
		t.Errorf("Can't create config file for a domain %v", err)
	}
	defer os.Remove(conf.Name())

	diskConfigs, diskStatuses := qemuDisks()
	config, aa := domainConfigAndAssignableAdapters(diskConfigs)
	config.VirtualizationMode = types.HVM
	config.BootLoader = "/usr/lib/xen/boot/ovmf.bin"
	if err := kvmArm.CreateDomConfig(DefaultDomainName, config, types.DomainStatus{},
		diskStatuses, &aa, nil, swtpmCtrlSock, conf); err != nil {
		t.Errorf("CreateDomConfig failed %v", err)
	}
	defer os.Truncate(conf.Name(), 0)

	result, err := os.ReadFile(conf.Name())
	if err != nil {
		t.Errorf("reading conf file failed %v", err)
	}

	result = setStaticVsockCid(result)
	if string(result) != domConfigArm64() {
		t.Errorf("got an unexpected resulting config %s", string(result))
	}
}

func addNonExistingAdapter(config *types.DomainConfig, aa *types.AssignableAdapters) {
	config.IoAdapterList = append(config.IoAdapterList, types.IoAdapter{
		Type: types.IoNetEth,
		Name: "eth1",
	})

	aa.IoBundleList = append(aa.IoBundleList, types.IoBundle{
		Type:            types.IoNetEth,
		AssignmentGroup: "eth1-1",
		Phylabel:        "eth1",
		Ifname:          "eth1",
		PciLong:         "0000:f4:00.0",
		UsedByUUID:      config.UUIDandVersion.UUID,
	})
}

func qemuDisks() ([]types.DiskConfig, []types.DiskStatus) {
	dc := []types.DiskConfig{
		{Format: zconfig.Format_QCOW2, FileLocation: "/foo/bar.qcow2"},
		{Format: zconfig.Format_CONTAINER, FileLocation: "/foo/container"},
		{Format: zconfig.Format_RAW, FileLocation: "/foo/bar.raw"},
		{Format: zconfig.Format_RAW, FileLocation: "/foo/cd.iso"},
		{Format: zconfig.Format_CONTAINER, FileLocation: "/foo/volume"},
		{Format: zconfig.Format_RAW, WWN: "naa.000000000000000a"},
	}
	ds := []types.DiskStatus{
		{Format: zconfig.Format_QCOW2, FileLocation: "/foo/bar.qcow2", Devtype: "hdd"},
		{Format: zconfig.Format_CONTAINER, FileLocation: "/foo/container", Devtype: "9P"},
		{Format: zconfig.Format_RAW, FileLocation: "/foo/bar.raw", Devtype: "hdd"},
		{Format: zconfig.Format_RAW, FileLocation: "/foo/cd.iso", Devtype: "cdrom"},
		{Format: zconfig.Format_CONTAINER, FileLocation: "/foo/volume", Devtype: ""},
		{Format: zconfig.Format_RAW, WWN: "naa.000000000000000a", Devtype: "hdd"},
	}
	return dc, ds
}

func domainConfigAndAssignableAdapters(dcl []types.DiskConfig) (types.DomainConfig, types.AssignableAdapters) {
	id, err := uuid.NewV4()
	if err != nil {
		panic(fmt.Errorf("NewV4 failed: %v", err))
	}

	config := types.DomainConfig{
		UUIDandVersion: types.UUIDandVersion{UUID: id, Version: "1.0"},
		VmConfig: types.VmConfig{
			Kernel:     "/boot/kernel",
			Ramdisk:    "/boot/ramdisk",
			ExtraArgs:  "init=/bin/sh",
			Memory:     1024 * 1024 * 10,
			VCpus:      2,
			VncDisplay: 5,
			VncPasswd:  "rosebud",
		},
		GPUConfig:      "legacy",
		DiskConfigList: dcl,
		VifList: []types.VifConfig{
			{Bridge: "bn0", Mac: net.HardwareAddr{0x6a, 0x00, 0x03, 0x61, 0xa6, 0x90}, Vif: "nbu1x1"},
			{Bridge: "bn0", Mac: net.HardwareAddr{0x6a, 0x00, 0x03, 0x61, 0xa6, 0x91}, Vif: "nbu1x2"},
		},
		IoAdapterList: []types.IoAdapter{
			{Type: types.IoNetEth, Name: "eth0"},
			{Type: types.IoCom, Name: "COM1"},
			{Type: types.IoUSB, Name: "USB1"},
		},
	}

	aa := types.AssignableAdapters{
		Initialized: true,
		IoBundleList: []types.IoBundle{
			{
				Type:            types.IoNetEth,
				AssignmentGroup: "eth0-1",
				Phylabel:        "eth0",
				Ifname:          "eth0",
				PciLong:         "0000:f3:00.0",
				UsedByUUID:      config.UUIDandVersion.UUID,
			},
			{
				Type:            types.IoCom,
				AssignmentGroup: "COM1",
				Phylabel:        "COM1",
				Ifname:          "COM1",
				Serial:          "/dev/ttyS0",
				UsedByUUID:      config.UUIDandVersion.UUID,
			},
			{
				Type:            types.IoUSB,
				AssignmentGroup: "USB1",
				Phylabel:        "USB1:1",
				UsbAddr:         "1:1",
				UsedByUUID:      config.UUIDandVersion.UUID,
			},
		},
	}
	return config, aa
}

func qemuDisksLegacy() ([]types.DiskConfig, []types.DiskStatus) {
	dc := []types.DiskConfig{
		{Format: zconfig.Format_QCOW2, FileLocation: "/foo/bar.qcow2"},
		{Format: zconfig.Format_CONTAINER, FileLocation: "/foo/container"},
		{Format: zconfig.Format_RAW, FileLocation: "/foo/bar.raw"},
		{Format: zconfig.Format_RAW, FileLocation: "/foo/cd.iso"},
		{Format: zconfig.Format_CONTAINER, FileLocation: "/foo/volume"},
		{Format: zconfig.Format_RAW, WWN: "naa.000000000000000a"},
	}
	ds := []types.DiskStatus{
		{Format: zconfig.Format_QCOW2, FileLocation: "/foo/bar.qcow2", Devtype: "legacy"},
		{Format: zconfig.Format_CONTAINER, FileLocation: "/foo/container", Devtype: "9P"},
		{Format: zconfig.Format_RAW, FileLocation: "/foo/bar.raw", Devtype: "legacy"},
		{Format: zconfig.Format_RAW, FileLocation: "/foo/cd.iso", Devtype: "cdrom"},
		{Format: zconfig.Format_CONTAINER, FileLocation: "/foo/volume", Devtype: ""},
		{Format: zconfig.Format_RAW, WWN: "naa.000000000000000a", Devtype: "legacy"},
	}
	return dc, ds
}

func domConfigArm64() string {
	return fmt.Sprintf(`# This file is automatically generated by domainmgr
[msg]
  timestamp = "on"

[machine]
  type = "virt"
  dump-guest-core = "off"
  accel = "kvm:tcg"
  gic-version = "host"
  firmware = "/usr/lib/xen/boot/ovmf.bin"
  kernel = "/boot/kernel"
  initrd = "/boot/ramdisk"
  append = "init=/bin/sh"


[overcommit]
  mem-lock = "off"

[chardev "charmonitor"]
  backend = "socket"
  path = "/run/hypervisor/kvm/%s/qmp"
  server = "on"
  wait = "off"

[mon "monitor"]
  chardev = "charmonitor"
  mode = "control"

[chardev "charlistener"]
  backend = "socket"
  path = "/run/hypervisor/kvm/%s/listener.qmp"
  server = "on"
  wait = "off"

[mon "listener"]
  chardev = "charlistener"
  mode = "control"

[memory]
  size = "10240"

[smp-opts]
  cpus = "2"
  sockets = "1"
  cores = "2"
  threads = "1"

[device]
  driver = "virtio-serial"
  addr = "3"

[chardev "charserial0"]
  backend = "socket"
  mux = "on"
  path = "/run/hypervisor/kvm/%s/cons"
  server = "on"
  wait = "off"
  logfile = "/dev/fd/1"
  logappend = "on"

[device]
  driver = "virtconsole"
  chardev = "charserial0"
  name = "org.lfedge.eve.console.0"



#[device "video0"]
#  driver = "qxl-vga"
#  ram_size = "67108864"
#  vram_size = "67108864"
#  vram64_size_mb = "0"
#  vgamem_mb = "16"
#  max_outputs = "1"
#  bus = "pcie.0"
#  addr = "0x1"

[device "video0"]
  driver = "virtio-gpu-pci"

[device "pci.2"]
  driver = "pcie-root-port"
  port = "12"
  chassis = "2"
  bus = "pcie.0"
  addr = "0x2"

[device "usb"]
  driver = "qemu-xhci"
  p2 = "15"
  p3 = "15"
  bus = "pci.2"
  addr = "0x0"

[device "input0"]
  driver = "usb-kbd"
  bus = "usb.0"
  port = "1"

[device "input1"]
  driver = "usb-mouse"
  bus = "usb.0"
  port = "2"


[device "pci.4"]
  driver = "pcie-root-port"
  port = "14"
  chassis = "4"
  bus = "pcie.0"
  addr = "0x4"

[drive "drive-virtio-disk0"]
  file = "/foo/bar.qcow2"
  format = "qcow2"
  aio = "io_uring"
  cache = "writeback"
  if = "none"

[device "virtio-disk0"]
  driver = "virtio-blk-pci"
  scsi = "off"
  bus = "pci.4"
  addr = "0x0"
  drive = "drive-virtio-disk0"


[fsdev "fsdev1"]
  fsdriver = "local"
  security_model = "none"
  multidevs = "remap"
  path = "/foo/container"

[device "fs1"]
  driver = "virtio-9p-pci"
  fsdev = "fsdev1"
  mount_tag = "share_dir"
  addr = "0x5"


[device "pci.6"]
  driver = "pcie-root-port"
  port = "16"
  chassis = "6"
  bus = "pcie.0"
  addr = "0x6"

[drive "drive-virtio-disk2"]
  file = "/foo/bar.raw"
  format = "raw"
  aio = "io_uring"
  cache = "writeback"
  if = "none"

[device "virtio-disk2"]
  driver = "virtio-blk-pci"
  scsi = "off"
  bus = "pci.6"
  addr = "0x0"
  drive = "drive-virtio-disk2"


[drive "drive-sata0-3"]
  file = "/foo/cd.iso"
  format = "raw"
  if = "none"
  media = "cdrom"
  readonly = "on"

[device "sata0-0"]
  drive = "drive-sata0-3"
  driver = "usb-storage"



[device "pci.7"]
  driver = "pcie-root-port"
  port = "17"
  chassis = "7"
  bus = "pcie.0"
  addr = "0x7"

[device "vhost-disk4"]
  driver = "vhost-scsi-pci"
  max_sectors = "16384"
  wwpn = "naa.000000000000000a"
  bus = "pci.7"
  addr = "0x0"
  num_queues = "2"

[device "pci.8"]
  driver = "pcie-root-port"
  port = "18"
  chassis = "8"
  bus = "pcie.0"
  multifunction = "on"
  addr = "0x8"

[netdev "hostnet0"]
  type = "tap"
  ifname = "nbu1x1"
  br = "bn0"
  script = "/etc/xen/scripts/qemu-ifup"
  downscript = "no"
  vhost = "on"

[device "net0"]
  driver = "virtio-net-pci"
  netdev = "hostnet0"
  mac = "6a:00:03:61:a6:90"
  bus = "pci.8"
  addr = "0x0"

[device "pci.9"]
  driver = "pcie-root-port"
  port = "19"
  chassis = "9"
  bus = "pcie.0"
  multifunction = "on"
  addr = "0x9"

[netdev "hostnet1"]
  type = "tap"
  ifname = "nbu1x2"
  br = "bn0"
  script = "/etc/xen/scripts/qemu-ifup"
  downscript = "no"
  vhost = "on"

[device "net1"]
  driver = "virtio-net-pci"
  netdev = "hostnet1"
  mac = "6a:00:03:61:a6:91"
  bus = "pci.9"
  addr = "0x0"

[device "pci.10"]
  driver = "pcie-root-port"
  port = "110"
  chassis = "10"
  bus = "pcie.0"
  multifunction = "on"
  addr = "0xa"

[device]
  driver = "vfio-pci"
  host = "f3:00.0"
  bus = "pci.10"
  addr = "0x0"

[chardev "charserial-usr0"]
  backend = "serial"
  path = "/dev/ttyS0"

[device "serial-usr0"]
  driver = "pci-serial"
  chardev = "charserial-usr0"

[device "eve-vsock0"]
  driver = "vhost-vsock-pci"
  disable-legacy = "on"
  guest-cid = "3"
`, DefaultDomainName, DefaultDomainName, DefaultDomainName)
}

func domConfigAmd64FML() string {
	return fmt.Sprintf(`# This file is automatically generated by domainmgr
[msg]
  timestamp = "on"

[machine]
  type = "pc-q35-3.1"
  dump-guest-core = "off"
  accel = "kvm"
  vmport = "off"
  kernel-irqchip = "on"
  kernel = "/boot/kernel"
  initrd = "/boot/ramdisk"
  append = "init=/bin/sh"

[global]
  driver = "kvm-pit"
  property = "lost_tick_policy"
  value = "delay"

[global]
  driver = "ICH9-LPC"
  property = "disable_s3"
  value = "1"

[global]
  driver = "ICH9-LPC"
  property = "disable_s4"
  value = "1"

[rtc]
  base = "localtime"
  driftfix = "slew"

[device]
  driver = "intel-iommu"
  caching-mode = "on"

[drive "drive-ovmf-code"]
  if = "pflash"
  format = "raw"
  readonly = "on"
  unit = "0"
  file = "/usr/lib/xen/boot/OVMF_CODE.fd"

[drive "drive-ovmf-vars"]
  if = "pflash"
  format = "raw"
  unit = "1"
  file = "/persist/vault/ovmf/%s_OVMF_VARS.fd"

[overcommit]
  mem-lock = "off"

[chardev "charmonitor"]
  backend = "socket"
  path = "/run/hypervisor/kvm/%s/qmp"
  server = "on"
  wait = "off"

[mon "monitor"]
  chardev = "charmonitor"
  mode = "control"

[chardev "charlistener"]
  backend = "socket"
  path = "/run/hypervisor/kvm/%s/listener.qmp"
  server = "on"
  wait = "off"

[mon "listener"]
  chardev = "charlistener"
  mode = "control"

[memory]
  size = "10240"

[smp-opts]
  cpus = "2"
  sockets = "1"
  cores = "2"
  threads = "1"

[device]
  driver = "virtio-serial"
  addr = "3"

[chardev "charserial0"]
  backend = "socket"
  mux = "on"
  path = "/run/hypervisor/kvm/%s/cons"
  server = "on"
  wait = "off"
  logfile = "/dev/fd/1"
  logappend = "on"

[device]
  driver = "virtconsole"
  chardev = "charserial0"
  name = "org.lfedge.eve.console.0"



#[device "video0"]
#  driver = "qxl-vga"
#  ram_size = "67108864"
#  vram_size = "67108864"
#  vram64_size_mb = "0"
#  vgamem_mb = "16"
#  max_outputs = "1"
#  bus = "pcie.0"
#  addr = "0x1"

[device "video0"]
  driver = "VGA"
  vgamem_mb = "16"
  bus = "pcie.0"
  addr = "0x1"

[device "pci.2"]
  driver = "pcie-root-port"
  port = "12"
  chassis = "2"
  bus = "pcie.0"
  addr = "0x2"

[device "usb"]
  driver = "qemu-xhci"
  p2 = "15"
  p3 = "15"
  bus = "pci.2"
  addr = "0x0"

[device "input0"]
  driver = "usb-tablet"
  bus = "usb.0"
  port = "1"


[device "pci.4"]
  driver = "pcie-root-port"
  port = "14"
  chassis = "4"
  bus = "pcie.0"
  addr = "0x4"

[drive "drive-virtio-disk0"]
  file = "/foo/bar.qcow2"
  format = "qcow2"
  aio = "io_uring"
  cache = "writeback"
  if = "none"

[device "virtio-disk0"]
  driver = "virtio-blk-pci"
  scsi = "off"
  bus = "pci.4"
  addr = "0x0"
  drive = "drive-virtio-disk0"


[fsdev "fsdev1"]
  fsdriver = "local"
  security_model = "none"
  multidevs = "remap"
  path = "/foo/container"

[device "fs1"]
  driver = "virtio-9p-pci"
  fsdev = "fsdev1"
  mount_tag = "share_dir"
  addr = "0x5"


[device "pci.6"]
  driver = "pcie-root-port"
  port = "16"
  chassis = "6"
  bus = "pcie.0"
  addr = "0x6"

[drive "drive-virtio-disk2"]
  file = "/foo/bar.raw"
  format = "raw"
  aio = "io_uring"
  cache = "writeback"
  if = "none"

[device "virtio-disk2"]
  driver = "virtio-blk-pci"
  scsi = "off"
  bus = "pci.6"
  addr = "0x0"
  drive = "drive-virtio-disk2"


[drive "drive-sata0-3"]
  file = "/foo/cd.iso"
  format = "raw"
  if = "none"
  media = "cdrom"
  readonly = "on"

[device "sata0-0"]
  drive = "drive-sata0-3"
  driver = "ide-cd"
  bus = "ide.0"


[device "pci.7"]
  driver = "pcie-root-port"
  port = "17"
  chassis = "7"
  bus = "pcie.0"
  addr = "0x7"

[device "vhost-disk4"]
  driver = "vhost-scsi-pci"
  max_sectors = "16384"
  wwpn = "naa.000000000000000a"
  bus = "pci.7"
  addr = "0x0"
  num_queues = "2"

[device "pci.8"]
  driver = "pcie-root-port"
  port = "18"
  chassis = "8"
  bus = "pcie.0"
  multifunction = "on"
  addr = "0x8"

[netdev "hostnet0"]
  type = "tap"
  ifname = "nbu1x1"
  br = "bn0"
  script = "/etc/xen/scripts/qemu-ifup"
  downscript = "no"
  vhost = "on"

[device "net0"]
  driver = "virtio-net-pci"
  netdev = "hostnet0"
  mac = "6a:00:03:61:a6:90"
  bus = "pci.8"
  addr = "0x0"

[device "pci.9"]
  driver = "pcie-root-port"
  port = "19"
  chassis = "9"
  bus = "pcie.0"
  multifunction = "on"
  addr = "0x9"

[netdev "hostnet1"]
  type = "tap"
  ifname = "nbu1x2"
  br = "bn0"
  script = "/etc/xen/scripts/qemu-ifup"
  downscript = "no"
  vhost = "on"

[device "net1"]
  driver = "virtio-net-pci"
  netdev = "hostnet1"
  mac = "6a:00:03:61:a6:91"
  bus = "pci.9"
  addr = "0x0"

[device "pci.10"]
  driver = "pcie-root-port"
  port = "110"
  chassis = "10"
  bus = "pcie.0"
  multifunction = "on"
  addr = "0xa"

[device]
  driver = "vfio-pci"
  host = "f3:00.0"
  bus = "pci.10"
  addr = "0x0"

[device "pci.11"]
  driver = "pcie-root-port"
  port = "111"
  chassis = "11"
  bus = "pcie.0"
  multifunction = "on"
  addr = "0xb"

[device]
  driver = "vfio-pci"
  host = "f4:00.0"
  bus = "pci.11"
  addr = "0x0"

[chardev "charserial-usr0"]
  backend = "serial"
  path = "/dev/ttyS0"

[device "serial-usr0"]
  driver = "isa-serial"
  chardev = "charserial-usr0"

[device "eve-vsock0"]
  driver = "vhost-vsock-pci"
  disable-legacy = "on"
  guest-cid = "3"
`, DefaultUUID, DefaultDomainName, DefaultDomainName, DefaultDomainName)
}

func domConfigAmd64Legacy() string {
	return fmt.Sprintf(`# This file is automatically generated by domainmgr
[msg]
  timestamp = "on"

[machine]
  type = "pc-q35-3.1"
  dump-guest-core = "off"
  accel = "kvm"
  vmport = "off"
  kernel-irqchip = "on"
  kernel = "/boot/kernel"
  initrd = "/boot/ramdisk"
  append = "init=/bin/sh"

[global]
  driver = "kvm-pit"
  property = "lost_tick_policy"
  value = "delay"

[global]
  driver = "ICH9-LPC"
  property = "disable_s3"
  value = "1"

[global]
  driver = "ICH9-LPC"
  property = "disable_s4"
  value = "1"

[rtc]
  base = "localtime"
  driftfix = "slew"

[device]
  driver = "intel-iommu"
  caching-mode = "on"

[overcommit]
  mem-lock = "off"

[chardev "charmonitor"]
  backend = "socket"
  path = "/run/hypervisor/kvm/%s/qmp"
  server = "on"
  wait = "off"

[mon "monitor"]
  chardev = "charmonitor"
  mode = "control"

[chardev "charlistener"]
  backend = "socket"
  path = "/run/hypervisor/kvm/%s/listener.qmp"
  server = "on"
  wait = "off"

[mon "listener"]
  chardev = "charlistener"
  mode = "control"

[memory]
  size = "10240"

[smp-opts]
  cpus = "2"
  sockets = "1"
  cores = "2"
  threads = "1"

[device]
  driver = "virtio-serial"
  addr = "3"

[chardev "charserial0"]
  backend = "socket"
  mux = "on"
  path = "/run/hypervisor/kvm/%s/cons"
  server = "on"
  wait = "off"
  logfile = "/dev/fd/1"
  logappend = "on"

[device]
  driver = "virtconsole"
  chardev = "charserial0"
  name = "org.lfedge.eve.console.0"



#[device "video0"]
#  driver = "qxl-vga"
#  ram_size = "67108864"
#  vram_size = "67108864"
#  vram64_size_mb = "0"
#  vgamem_mb = "16"
#  max_outputs = "1"
#  bus = "pcie.0"
#  addr = "0x1"

[device "video0"]
  driver = "VGA"
  vgamem_mb = "16"
  bus = "pcie.0"
  addr = "0x1"

[device "pci.2"]
  driver = "pcie-root-port"
  port = "12"
  chassis = "2"
  bus = "pcie.0"
  addr = "0x2"

[device "usb"]
  driver = "qemu-xhci"
  p2 = "15"
  p3 = "15"
  bus = "pci.2"
  addr = "0x0"

[device "input0"]
  driver = "usb-tablet"
  bus = "usb.0"
  port = "1"


[device "pci.4"]
  driver = "pcie-root-port"
  port = "14"
  chassis = "4"
  bus = "pcie.0"
  addr = "0x4"

[drive "drive-virtio-disk0"]
  file = "/foo/bar.qcow2"
  format = "qcow2"
  aio = "io_uring"
  cache = "writeback"
  if = "none"

[device "ahci.4"]
  bus = "pci.4"
  driver = "ahci"

[device "ahci-disk0"]
  driver = "ide-hd"
  bus = "ahci.4.0"
  drive = "drive-virtio-disk0"


[fsdev "fsdev1"]
  fsdriver = "local"
  security_model = "none"
  multidevs = "remap"
  path = "/foo/container"

[device "fs1"]
  driver = "virtio-9p-pci"
  fsdev = "fsdev1"
  mount_tag = "share_dir"
  addr = "0x5"


[device "pci.6"]
  driver = "pcie-root-port"
  port = "16"
  chassis = "6"
  bus = "pcie.0"
  addr = "0x6"

[drive "drive-virtio-disk2"]
  file = "/foo/bar.raw"
  format = "raw"
  aio = "io_uring"
  cache = "writeback"
  if = "none"

[device "ahci.6"]
  bus = "pci.6"
  driver = "ahci"

[device "ahci-disk2"]
  driver = "ide-hd"
  bus = "ahci.6.0"
  drive = "drive-virtio-disk2"


[drive "drive-sata0-3"]
  file = "/foo/cd.iso"
  format = "raw"
  if = "none"
  media = "cdrom"
  readonly = "on"

[device "sata0-0"]
  drive = "drive-sata0-3"
  driver = "ide-cd"
  bus = "ide.0"


[device "pci.7"]
  driver = "pcie-root-port"
  port = "17"
  chassis = "7"
  bus = "pcie.0"
  addr = "0x7"

[device "vhost-disk4"]
  driver = "vhost-scsi-pci"
  max_sectors = "16384"
  wwpn = "naa.000000000000000a"
  bus = "pci.7"
  addr = "0x0"
  num_queues = "2"

[device "pci.8"]
  driver = "pcie-root-port"
  port = "18"
  chassis = "8"
  bus = "pcie.0"
  multifunction = "on"
  addr = "0x8"

[netdev "hostnet0"]
  type = "tap"
  ifname = "nbu1x1"
  br = "bn0"
  script = "/etc/xen/scripts/qemu-ifup"
  downscript = "no"

[device "net0"]
  driver = "e1000"
  netdev = "hostnet0"
  mac = "6a:00:03:61:a6:90"
  bus = "pci.8"
  addr = "0x0"

[device "pci.9"]
  driver = "pcie-root-port"
  port = "19"
  chassis = "9"
  bus = "pcie.0"
  multifunction = "on"
  addr = "0x9"

[netdev "hostnet1"]
  type = "tap"
  ifname = "nbu1x2"
  br = "bn0"
  script = "/etc/xen/scripts/qemu-ifup"
  downscript = "no"

[device "net1"]
  driver = "e1000"
  netdev = "hostnet1"
  mac = "6a:00:03:61:a6:91"
  bus = "pci.9"
  addr = "0x0"

[device "pci.10"]
  driver = "pcie-root-port"
  port = "110"
  chassis = "10"
  bus = "pcie.0"
  multifunction = "on"
  addr = "0xa"

[device]
  driver = "vfio-pci"
  host = "f3:00.0"
  bus = "pci.10"
  addr = "0x0"

[chardev "charserial-usr0"]
  backend = "serial"
  path = "/dev/ttyS0"

[device "serial-usr0"]
  driver = "isa-serial"
  chardev = "charserial-usr0"

[device "eve-vsock0"]
  driver = "vhost-vsock-pci"
  disable-legacy = "on"
  guest-cid = "3"
`, DefaultDomainName, DefaultDomainName, DefaultDomainName)
}

func domConfigAmd64() string {
	return fmt.Sprintf(`# This file is automatically generated by domainmgr
[msg]
  timestamp = "on"

[machine]
  type = "pc-q35-3.1"
  dump-guest-core = "off"
  accel = "kvm"
  vmport = "off"
  kernel-irqchip = "on"
  kernel = "/boot/kernel"
  initrd = "/boot/ramdisk"
  append = "init=/bin/sh"

[global]
  driver = "kvm-pit"
  property = "lost_tick_policy"
  value = "delay"

[global]
  driver = "ICH9-LPC"
  property = "disable_s3"
  value = "1"

[global]
  driver = "ICH9-LPC"
  property = "disable_s4"
  value = "1"

[rtc]
  base = "localtime"
  driftfix = "slew"

[device]
  driver = "intel-iommu"
  caching-mode = "on"

[overcommit]
  mem-lock = "off"

[chardev "charmonitor"]
  backend = "socket"
  path = "/run/hypervisor/kvm/%s/qmp"
  server = "on"
  wait = "off"

[mon "monitor"]
  chardev = "charmonitor"
  mode = "control"

[chardev "charlistener"]
  backend = "socket"
  path = "/run/hypervisor/kvm/%s/listener.qmp"
  server = "on"
  wait = "off"

[mon "listener"]
  chardev = "charlistener"
  mode = "control"

[memory]
  size = "10240"

[smp-opts]
  cpus = "2"
  sockets = "1"
  cores = "2"
  threads = "1"

[device]
  driver = "virtio-serial"
  addr = "3"

[chardev "charserial0"]
  backend = "socket"
  mux = "on"
  path = "/run/hypervisor/kvm/%s/cons"
  server = "on"
  wait = "off"
  logfile = "/dev/fd/1"
  logappend = "on"

[device]
  driver = "virtconsole"
  chardev = "charserial0"
  name = "org.lfedge.eve.console.0"



#[device "video0"]
#  driver = "qxl-vga"
#  ram_size = "67108864"
#  vram_size = "67108864"
#  vram64_size_mb = "0"
#  vgamem_mb = "16"
#  max_outputs = "1"
#  bus = "pcie.0"
#  addr = "0x1"

[device "video0"]
  driver = "VGA"
  vgamem_mb = "16"
  bus = "pcie.0"
  addr = "0x1"

[device "pci.2"]
  driver = "pcie-root-port"
  port = "12"
  chassis = "2"
  bus = "pcie.0"
  addr = "0x2"

[device "usb"]
  driver = "qemu-xhci"
  p2 = "15"
  p3 = "15"
  bus = "pci.2"
  addr = "0x0"

[device "input0"]
  driver = "usb-tablet"
  bus = "usb.0"
  port = "1"


[device "pci.4"]
  driver = "pcie-root-port"
  port = "14"
  chassis = "4"
  bus = "pcie.0"
  addr = "0x4"

[drive "drive-virtio-disk0"]
  file = "/foo/bar.qcow2"
  format = "qcow2"
  aio = "io_uring"
  cache = "writeback"
  if = "none"

[device "virtio-disk0"]
  driver = "virtio-blk-pci"
  scsi = "off"
  bus = "pci.4"
  addr = "0x0"
  drive = "drive-virtio-disk0"


[fsdev "fsdev1"]
  fsdriver = "local"
  security_model = "none"
  multidevs = "remap"
  path = "/foo/container"

[device "fs1"]
  driver = "virtio-9p-pci"
  fsdev = "fsdev1"
  mount_tag = "share_dir"
  addr = "0x5"


[device "pci.6"]
  driver = "pcie-root-port"
  port = "16"
  chassis = "6"
  bus = "pcie.0"
  addr = "0x6"

[drive "drive-virtio-disk2"]
  file = "/foo/bar.raw"
  format = "raw"
  aio = "io_uring"
  cache = "writeback"
  if = "none"

[device "virtio-disk2"]
  driver = "virtio-blk-pci"
  scsi = "off"
  bus = "pci.6"
  addr = "0x0"
  drive = "drive-virtio-disk2"


[drive "drive-sata0-3"]
  file = "/foo/cd.iso"
  format = "raw"
  if = "none"
  media = "cdrom"
  readonly = "on"

[device "sata0-0"]
  drive = "drive-sata0-3"
  driver = "ide-cd"
  bus = "ide.0"


[device "pci.7"]
  driver = "pcie-root-port"
  port = "17"
  chassis = "7"
  bus = "pcie.0"
  addr = "0x7"

[device "vhost-disk4"]
  driver = "vhost-scsi-pci"
  max_sectors = "16384"
  wwpn = "naa.000000000000000a"
  bus = "pci.7"
  addr = "0x0"
  num_queues = "2"

[device "pci.8"]
  driver = "pcie-root-port"
  port = "18"
  chassis = "8"
  bus = "pcie.0"
  multifunction = "on"
  addr = "0x8"

[netdev "hostnet0"]
  type = "tap"
  ifname = "nbu1x1"
  br = "bn0"
  script = "/etc/xen/scripts/qemu-ifup"
  downscript = "no"
  vhost = "on"

[device "net0"]
  driver = "virtio-net-pci"
  netdev = "hostnet0"
  mac = "6a:00:03:61:a6:90"
  bus = "pci.8"
  addr = "0x0"

[device "pci.9"]
  driver = "pcie-root-port"
  port = "19"
  chassis = "9"
  bus = "pcie.0"
  multifunction = "on"
  addr = "0x9"

[netdev "hostnet1"]
  type = "tap"
  ifname = "nbu1x2"
  br = "bn0"
  script = "/etc/xen/scripts/qemu-ifup"
  downscript = "no"
  vhost = "on"

[device "net1"]
  driver = "virtio-net-pci"
  netdev = "hostnet1"
  mac = "6a:00:03:61:a6:91"
  bus = "pci.9"
  addr = "0x0"

[device "pci.10"]
  driver = "pcie-root-port"
  port = "110"
  chassis = "10"
  bus = "pcie.0"
  multifunction = "on"
  addr = "0xa"

[device]
  driver = "vfio-pci"
  host = "f3:00.0"
  bus = "pci.10"
  addr = "0x0"

[chardev "charserial-usr0"]
  backend = "serial"
  path = "/dev/ttyS0"

[device "serial-usr0"]
  driver = "isa-serial"
  chardev = "charserial-usr0"

[device "eve-vsock0"]
  driver = "vhost-vsock-pci"
  disable-legacy = "on"
  guest-cid = "3"
`, DefaultDomainName, DefaultDomainName, DefaultDomainName)
}

func domConfigContainerVNC() string {
	return fmt.Sprintf(`# This file is automatically generated by domainmgr
[msg]
  timestamp = "on"

[machine]
  type = "pc-q35-3.1"
  dump-guest-core = "off"
  accel = "kvm"
  vmport = "off"
  kernel-irqchip = "on"
  kernel = "/boot/kernel"
  initrd = "/boot/ramdisk"
  append = "init=/bin/sh"

[global]
  driver = "kvm-pit"
  property = "lost_tick_policy"
  value = "delay"

[global]
  driver = "ICH9-LPC"
  property = "disable_s3"
  value = "1"

[global]
  driver = "ICH9-LPC"
  property = "disable_s4"
  value = "1"

[rtc]
  base = "localtime"
  driftfix = "slew"

[device]
  driver = "intel-iommu"
  caching-mode = "on"

[overcommit]
  mem-lock = "off"

[chardev "charmonitor"]
  backend = "socket"
  path = "/run/hypervisor/kvm/%s/qmp"
  server = "on"
  wait = "off"

[mon "monitor"]
  chardev = "charmonitor"
  mode = "control"

[chardev "charlistener"]
  backend = "socket"
  path = "/run/hypervisor/kvm/%s/listener.qmp"
  server = "on"
  wait = "off"

[mon "listener"]
  chardev = "charlistener"
  mode = "control"

[memory]
  size = "10240"

[smp-opts]
  cpus = "2"
  sockets = "1"
  cores = "2"
  threads = "1"

[device]
  driver = "virtio-serial"
  addr = "3"

[chardev "charserial0"]
  backend = "socket"
  mux = "on"
  path = "/run/hypervisor/kvm/%s/cons"
  server = "on"
  wait = "off"
  logfile = "/dev/fd/1"
  logappend = "on"

[device]
  driver = "virtconsole"
  chardev = "charserial0"
  name = "org.lfedge.eve.console.0"

[chardev "charserial1"]
  backend = "socket"
  path = "/run/hypervisor/kvm/%s/shim-cons"
  server = "on"
  wait = "off"

[chardev "charserial2"]
  backend = "vc"

[chardev "charhub0"]
  backend = "hub"
  chardevs.0 = "charserial1"
  chardevs.1 = "charserial2"
  logfile = "/dev/fd/1"
  logappend = "on"

[device]
  driver = "virtconsole"
  chardev = "charhub0"
  name = "org.lfedge.eve.console.shim"


[vnc "default"]
  vnc = "0.0.0.0:5"
  to = "99"
  password = "on"
#[device "video0"]
#  driver = "qxl-vga"
#  ram_size = "67108864"
#  vram_size = "67108864"
#  vram64_size_mb = "0"
#  vgamem_mb = "16"
#  max_outputs = "1"
#  bus = "pcie.0"
#  addr = "0x1"

[device "video0"]
  driver = "VGA"
  vgamem_mb = "16"
  bus = "pcie.0"
  addr = "0x1"

[device "pci.2"]
  driver = "pcie-root-port"
  port = "12"
  chassis = "2"
  bus = "pcie.0"
  addr = "0x2"

[device "usb"]
  driver = "qemu-xhci"
  p2 = "15"
  p3 = "15"
  bus = "pci.2"
  addr = "0x0"

[device "input0"]
  driver = "usb-tablet"
  bus = "usb.0"
  port = "1"


[fsdev "fsdev0"]
  fsdriver = "local"
  security_model = "none"
  multidevs = "remap"
  path = "/foo/container"

[device "fs0"]
  driver = "virtio-9p-pci"
  fsdev = "fsdev0"
  mount_tag = "share_dir"
  addr = "0x4"


[device "pci.5"]
  driver = "pcie-root-port"
  port = "15"
  chassis = "5"
  bus = "pcie.0"
  addr = "0x5"

[drive "drive-virtio-disk1"]
  file = "/foo/bar.raw"
  format = "raw"
  aio = "io_uring"
  cache = "writeback"
  if = "none"

[device "virtio-disk1"]
  driver = "virtio-blk-pci"
  scsi = "off"
  bus = "pci.5"
  addr = "0x0"
  drive = "drive-virtio-disk1"


[drive "drive-sata0-2"]
  file = "/foo/cd.iso"
  format = "raw"
  if = "none"
  media = "cdrom"
  readonly = "on"

[device "sata0-0"]
  drive = "drive-sata0-2"
  driver = "ide-cd"
  bus = "ide.0"


[device "pci.6"]
  driver = "pcie-root-port"
  port = "16"
  chassis = "6"
  bus = "pcie.0"
  addr = "0x6"

[device "vhost-disk3"]
  driver = "vhost-scsi-pci"
  max_sectors = "16384"
  wwpn = "naa.000000000000000a"
  bus = "pci.6"
  addr = "0x0"
  num_queues = "2"

[device "pci.7"]
  driver = "pcie-root-port"
  port = "17"
  chassis = "7"
  bus = "pcie.0"
  multifunction = "on"
  addr = "0x7"

[netdev "hostnet0"]
  type = "tap"
  ifname = "nbu1x1"
  br = "bn0"
  script = "/etc/xen/scripts/qemu-ifup"
  downscript = "no"
  vhost = "on"

[device "net0"]
  driver = "virtio-net-pci"
  netdev = "hostnet0"
  mac = "6a:00:03:61:a6:90"
  bus = "pci.7"
  addr = "0x0"

[device "pci.8"]
  driver = "pcie-root-port"
  port = "18"
  chassis = "8"
  bus = "pcie.0"
  multifunction = "on"
  addr = "0x8"

[netdev "hostnet1"]
  type = "tap"
  ifname = "nbu1x2"
  br = "bn0"
  script = "/etc/xen/scripts/qemu-ifup"
  downscript = "no"
  vhost = "on"

[device "net1"]
  driver = "virtio-net-pci"
  netdev = "hostnet1"
  mac = "6a:00:03:61:a6:91"
  bus = "pci.8"
  addr = "0x0"

[device "pci.9"]
  driver = "pcie-root-port"
  port = "19"
  chassis = "9"
  bus = "pcie.0"
  multifunction = "on"
  addr = "0x9"

[device]
  driver = "vfio-pci"
  host = "f3:00.0"
  bus = "pci.9"
  addr = "0x0"

[chardev "charserial-usr0"]
  backend = "serial"
  path = "/dev/ttyS0"

[device "serial-usr0"]
  driver = "isa-serial"
  chardev = "charserial-usr0"

[device "eve-vsock0"]
  driver = "vhost-vsock-pci"
  disable-legacy = "on"
  guest-cid = "3"
`, DefaultDomainName, DefaultDomainName, DefaultDomainName, DefaultDomainName)
}

func TestCreateDom(t *testing.T) {
	if exec.Command("qemu-system-x86_64", "--version").Run() != nil {
		// skipping this test since we're clearly not in a presence of qemu
		return
	}
	id, err := uuid.NewV4()
	if err != nil {
		t.Errorf("NewV4 failed: %v", err)
	}
	config := types.DomainConfig{
		UUIDandVersion: types.UUIDandVersion{UUID: id, Version: "1.0"},
		VmConfig: types.VmConfig{
			Kernel:             "/boot/kernel",
			Ramdisk:            "/boot/ramdisk",
			ExtraArgs:          "init=/bin/sh",
			Memory:             1024 * 1024 * 10,
			VCpus:              2,
			VncDisplay:         5,
			VncPasswd:          "rosebud",
			VirtualizationMode: types.HVM,
		},
		GPUConfig: "legacy",
		VifList: []types.VifConfig{
			{Bridge: "bn0", Mac: net.HardwareAddr{0x6a, 0x00, 0x03, 0x61, 0xa6, 0x90}, Vif: "nbu1x1"},
			{Bridge: "bn0", Mac: net.HardwareAddr{0x6a, 0x00, 0x03, 0x61, 0xa6, 0x91}, Vif: "nbu1x2"},
		},
		IoAdapterList: []types.IoAdapter{
			{Type: types.IoNetEth, Name: "eth0"},
			{Type: types.IoCom, Name: "COM1"},
		},
	}
	os.RemoveAll(kvmStateDir)

	conf, err := os.CreateTemp("/tmp/", "config")
	if err != nil {
		t.Errorf("Can't create config file for a domain %v", err)
	} else {
		defer os.Remove(conf.Name())
	}
	os.WriteFile(conf.Name(), []byte(fmt.Sprintf(
		`# This file is automatically generated by domainmgr
[msg]
  timestamp = "on"

[machine]
  type = "pc-q35-3.1"
  vmport = "off"
  dump-guest-core = "off"

[global]
  driver = "ICH9-LPC"
  property = "disable_s3"
  value = "1"

[global]
  driver = "ICH9-LPC"
  property = "disable_s4"
  value = "1"

[overcommit]
  mem-lock = "off"

[rtc]
  base = "localtime"
  driftfix = "slew"

[chardev "charmonitor"]
  backend = "socket"
  path = "/run/hypervisor/kvm/%s/qmp"
  server = "on"
  wait = "off"

[chardev "charlistener"]
  backend = "socket"
  path = "/run/hypervisor/kvm/%s/listener.qmp"
  server = "on"
  wait = "off"

[mon "listener"]
  chardev = "charlistener"
  mode = "control"

[mon "monitor"]
  chardev = "charmonitor"
  mode = "control"

[memory]
  size = "1024"

[smp-opts]
  cpus = "2"
  sockets = "1"
  cores = "2"
  threads = "1"`, DefaultDomainName, DefaultDomainName)), 0777)

	if kvmIntel.ctrdClient == nil {
		t.Skipf("test must be run on a system with a functional containerd")
	}

	if _, err := kvmIntel.Task(testDom).Create("test", conf.Name(), &config); err != nil {
		t.Errorf("Create domain config failed %v", err)
	}

	state, err := os.Open(kvmStateDir + "/test")
	if err != nil {
		t.Errorf("can't open stat dir for test domain %v", err)
	}

	names, err := state.Readdirnames(0)
	if err != nil || len(names) != 3 {
		t.Errorf("can't read stat dir for test domain or got unexpected content %v", err)
	}

	for _, e := range names {
		if _, found := map[string]bool{"pid": true, "qmp": true, "cons": true}[e]; !found {
			t.Errorf("got an unexpected entry %s in the stat dir for domain test", e)
		}
	}

	if err := kvmIntel.Task(testDom).Start("test"); err != nil {
		t.Errorf("Start domain failed %v", err)
	}

	if err := kvmIntel.Task(testDom).Stop("test", true); err != nil {
		t.Errorf("Stop domain failed %v", err)
	}

	if err := kvmIntel.Task(testDom).Delete("test"); err != nil {
		t.Errorf("Delete domain failed %v", err)
	}

	if err := kvmIntel.Task(testDom).Cleanup("test"); err != nil {
		t.Errorf("Cleanup domain failed %v", err)
	}

	state, err = os.Open(kvmStateDir)
	if err != nil {
		t.Errorf("can't open stat dir for test domain %v", err)
	}

	names, err = state.Readdirnames(0)
	if err != nil || len(names) != 0 {
		t.Errorf("can't read stat dir for test domain or state dir is not empty after all domains are gone %v", err)
	}
}

func TestCreateDomConfigContainerVNC(t *testing.T) {
	t.Parallel()

	conf, err := os.CreateTemp("/tmp", "config")
	if err != nil {
		t.Errorf("Can't create config file for a domain %v", err)
	}
	defer os.Remove(conf.Name())

	diskConfigs, diskStatuses := qemuDisks()
	// remove the first disk, so that the container disk is the first one, resulting in IsOciContainer being true
	diskConfigs = diskConfigs[1:]
	diskStatuses = diskStatuses[1:]

	config, aa := domainConfigAndAssignableAdapters(diskConfigs)
	// enable VNC and VNC for shim VM
	config.VmConfig.EnableVnc = true
	config.VmConfig.EnableVncShimVM = true
	if err := kvmIntel.CreateDomConfig(DefaultDomainName, config, types.DomainStatus{},
		diskStatuses, &aa, nil, swtpmCtrlSock, conf); err != nil {
		t.Errorf("CreateDomConfig failed %v", err)
	}
	defer os.Truncate(conf.Name(), 0)

	result, err := os.ReadFile(conf.Name())
	if err != nil {
		t.Errorf("reading conf file failed %v", err)
	}

	result = setStaticVsockCid(result)
	if string(result) != domConfigContainerVNC() {
		t.Errorf("got an unexpected resulting config %s", string(result))
	}
}

func expectedMultifunctionDevice() string {
	return `
[device "pci.0"]
  driver = "pcie-root-port"
  port = "10"
  chassis = "0"
  bus = "pcie.0"
  multifunction = "on"
  addr = "0x0"

[device]
  driver = "vfio-pci"
  host = "00:0a.0"
  bus = "pci.0"
  addr = "0x0"

[device "pci.1"]
  driver = "pcie-root-port"
  port = "11"
  chassis = "1"
  bus = "pcie.0"
  multifunction = "on"
  addr = "0x1"

[device "pcie-bridge.1"]
  driver = "pcie-pci-bridge"
  bus = "pci.1"
  addr = "0x0"

[device]
  driver = "vfio-pci"
  host = "00:0d.0"
  bus = "pcie-bridge.1"
  addr = "0x1"

[device "pci.2"]
  driver = "pcie-root-port"
  port = "12"
  chassis = "2"
  bus = "pcie.0"
  multifunction = "on"
  addr = "0x2"

[device]
  driver = "vfio-pci"
  host = "00:0b.0"
  bus = "pci.2"
  addr = "0x0"

[device]
  driver = "vfio-pci"
  host = "00:0d.2"
  bus = "pcie-bridge.1"
  addr = "0x2"
`
}

func TestPCIAssignmentsTemplateFillMultifunctionDevice(t *testing.T) {
	pciAssignments := []pciDevice{
		{
			pciLong: "0000:00:0a.0",
			ioType:  0,
		},
		{
			pciLong: "0000:00:0d.0",
			ioType:  0,
		},
		{
			pciLong: "0000:00:0b.0",
			ioType:  0,
		},
		{
			pciLong: "0000:00:0d.2",
			ioType:  0,
		},
	}

	wr := bytes.Buffer{}
	multifunctionDevices := multifunctionDevGroup(pciAssignments)
	addrAllocator := pciAddressAllocator{
		pciAssignments:       pciAssignments,
		multifunctionDevices: multifunctionDevices,
	}
	if err := addrAllocator.allocate(); err != nil {
		t.Error(err)
	}

	p := pciAssignmentsTemplateFiller{
		multifunctionDevices: multifunctionDevices,
		file:                 &wr,
	}
	p.do(pciAssignments)

	if wr.String() != expectedMultifunctionDevice() {
		t.Fatalf("not equal, diff: \n%s\ncomplete:\n%s", cmp.Diff(wr.String(), expectedMultifunctionDevice()), wr.String())
	}
}

func TestConvertToMultifunctionPCIDevices(t *testing.T) {
	pciAssignments := []pciDevice{
		{
			pciLong: "0000:00:0d.0",
			ioType:  0,
		},
		{
			pciLong: "0000:00:aa.8",
			ioType:  0,
		},
		{
			pciLong: "0000:00:0d.2",
			ioType:  0,
		},
		{
			pciLong: "0000:00:0d.f",
			ioType:  0,
		},
	}

	mds := multifunctionDevGroup(pciAssignments)

	if len(mds) != 2 {
		t.Fatalf("expected two multifunction pci assignments, but got %d", len(mds))
	}

	t.Log(mds)
	for i, pci := range []string{"0000:00:0d.0", "0000:00:0d.2", "0000:00:0d.f"} {
		functionPCIDev := mds["0000:00:0d"].devs[i].pciLong
		if functionPCIDev != pci {
			t.Logf("expected %s got %s", pci, functionPCIDev)
			t.Fail()
		}
	}

	if len(mds["0000:00:aa"].devs) != 1 {
		t.Fatal("expected one device")
	}
}

func TestPCIAddressAllocator(t *testing.T) {
	g := NewGomegaWithT(t)
	virtualNetworks := []virtualNetwork{
		{
			VifConfig: types.VifConfig{
				Bridge:   "br1",
				Vif:      "nbu1x1",
				Mac:      net.HardwareAddr{0x02, 0x16, 0x3e, 0x00, 0x00, 0x01},
				MTU:      1500,
				VifOrder: 1,
			},
			networkID: 0,
		},
		{
			VifConfig: types.VifConfig{
				Bridge:   "br2",
				Vif:      "nbu2x1",
				Mac:      net.HardwareAddr{0x02, 0x16, 0x3e, 0x00, 0x00, 0x02},
				MTU:      1500,
				VifOrder: 4,
			},
			networkID: 1,
		},
	}
	pciAssignments := []pciDevice{
		{
			pciLong:      "0000:06:00.0",
			ioType:       types.IoNetEth,
			netIntfOrder: 2,
		},
		{
			pciLong: "0000:00:15.0",
			ioType:  types.IoUSB,
		},
		{
			pciLong: "0000:06:00.2",
			ioType:  types.IoOther,
		},
		{
			pciLong:      "0000:06:00.1",
			ioType:       types.IoNetEth,
			netIntfOrder: 3,
		},
		{
			pciLong:      "0000:08:00.0",
			ioType:       types.IoNetWWAN,
			netIntfOrder: 0,
		},
	}
	multifunctionDevices := multifunctionDevGroup(pciAssignments)
	g.Expect(multifunctionDevices).To(HaveLen(3))
	addrAllocator := pciAddressAllocator{
		pciAssignments:       pciAssignments,
		virtualNetworks:      virtualNetworks,
		multifunctionDevices: multifunctionDevices,
		firstFreePCIID:       5,
		// First test the legacy order.
		enforceNetInterfaceOrder: false,
	}
	err := addrAllocator.allocate()
	g.Expect(err).ToNot(HaveOccurred())

	g.Expect(virtualNetworks[0].pciDeviceID).To(Equal(5))
	g.Expect(virtualNetworks[1].pciDeviceID).To(Equal(6))
	g.Expect(pciAssignments[0].pciBridgeID).To(Equal(7))
	g.Expect(pciAssignments[0].pciDeviceID).To(Equal(1))
	g.Expect(pciAssignments[1].pciBridgeID).To(Equal(0))
	g.Expect(pciAssignments[1].pciDeviceID).To(Equal(8))
	g.Expect(pciAssignments[2].pciBridgeID).To(Equal(7))
	g.Expect(pciAssignments[2].pciDeviceID).To(Equal(2))
	g.Expect(pciAssignments[3].pciBridgeID).To(Equal(7))
	g.Expect(pciAssignments[3].pciDeviceID).To(Equal(3))
	g.Expect(pciAssignments[4].pciBridgeID).To(Equal(0))
	g.Expect(pciAssignments[4].pciDeviceID).To(Equal(9))

	// Check generated config with the legacy order.
	buffer := bytes.Buffer{}
	vnFiller := virtNetworkTemplateFiller{
		file: &buffer,
	}
	err = vnFiller.do(virtualNetworks, types.HVM)
	g.Expect(err).ToNot(HaveOccurred())
	paFiller := pciAssignmentsTemplateFiller{
		multifunctionDevices: multifunctionDevices,
		file:                 &buffer,
	}
	err = paFiller.do(pciAssignments)
	g.Expect(err).ToNot(HaveOccurred())
	expectedConfig := `
[device "pci.5"]
  driver = "pcie-root-port"
  port = "15"
  chassis = "5"
  bus = "pcie.0"
  multifunction = "on"
  addr = "0x5"

[netdev "hostnet0"]
  type = "tap"
  ifname = "nbu1x1"
  br = "br1"
  script = "/etc/xen/scripts/qemu-ifup"
  downscript = "no"
  vhost = "on"

[device "net0"]
  driver = "virtio-net-pci"
  netdev = "hostnet0"
  mac = "02:16:3e:00:00:01"
  bus = "pci.5"
  addr = "0x0"
  host_mtu = "1500"

[device "pci.6"]
  driver = "pcie-root-port"
  port = "16"
  chassis = "6"
  bus = "pcie.0"
  multifunction = "on"
  addr = "0x6"

[netdev "hostnet1"]
  type = "tap"
  ifname = "nbu2x1"
  br = "br2"
  script = "/etc/xen/scripts/qemu-ifup"
  downscript = "no"
  vhost = "on"

[device "net1"]
  driver = "virtio-net-pci"
  netdev = "hostnet1"
  mac = "02:16:3e:00:00:02"
  bus = "pci.6"
  addr = "0x0"
  host_mtu = "1500"

[device "pci.7"]
  driver = "pcie-root-port"
  port = "17"
  chassis = "7"
  bus = "pcie.0"
  multifunction = "on"
  addr = "0x7"

[device "pcie-bridge.7"]
  driver = "pcie-pci-bridge"
  bus = "pci.7"
  addr = "0x0"

[device]
  driver = "vfio-pci"
  host = "06:00.0"
  bus = "pcie-bridge.7"
  addr = "0x1"

[device "pci.8"]
  driver = "pcie-root-port"
  port = "18"
  chassis = "8"
  bus = "pcie.0"
  multifunction = "on"
  addr = "0x8"

[device]
  driver = "vfio-pci"
  host = "00:15.0"
  bus = "pci.8"
  addr = "0x0"

[device]
  driver = "vfio-pci"
  host = "06:00.2"
  bus = "pcie-bridge.7"
  addr = "0x2"

[device]
  driver = "vfio-pci"
  host = "06:00.1"
  bus = "pcie-bridge.7"
  addr = "0x3"

[device "pci.9"]
  driver = "pcie-root-port"
  port = "19"
  chassis = "9"
  bus = "pcie.0"
  multifunction = "on"
  addr = "0x9"

[device]
  driver = "vfio-pci"
  host = "08:00.0"
  bus = "pci.9"
  addr = "0x0"
`
	g.Expect(buffer.String()).To(Equal(expectedConfig))

	// Test enforced user-defined network interface order.
	addrAllocator.enforceNetInterfaceOrder = true
	err = addrAllocator.allocate()
	g.Expect(err).ToNot(HaveOccurred())

	g.Expect(virtualNetworks[0].pciDeviceID).To(Equal(6))
	g.Expect(virtualNetworks[1].pciDeviceID).To(Equal(8))
	g.Expect(pciAssignments[0].pciBridgeID).To(Equal(7))
	g.Expect(pciAssignments[0].pciDeviceID).To(Equal(1))
	g.Expect(pciAssignments[1].pciBridgeID).To(Equal(0))
	g.Expect(pciAssignments[1].pciDeviceID).To(Equal(9))
	g.Expect(pciAssignments[2].pciBridgeID).To(Equal(7))
	g.Expect(pciAssignments[2].pciDeviceID).To(Equal(3))
	g.Expect(pciAssignments[3].pciBridgeID).To(Equal(7))
	g.Expect(pciAssignments[3].pciDeviceID).To(Equal(2))
	g.Expect(pciAssignments[4].pciBridgeID).To(Equal(0))
	g.Expect(pciAssignments[4].pciDeviceID).To(Equal(5))

	// Check generated config with the user-defined order.
	buffer.Reset()
	err = vnFiller.do(virtualNetworks, types.HVM)
	g.Expect(err).ToNot(HaveOccurred())
	err = paFiller.do(pciAssignments)
	g.Expect(err).ToNot(HaveOccurred())
	expectedConfig = `
[device "pci.6"]
  driver = "pcie-root-port"
  port = "16"
  chassis = "6"
  bus = "pcie.0"
  multifunction = "on"
  addr = "0x6"

[netdev "hostnet0"]
  type = "tap"
  ifname = "nbu1x1"
  br = "br1"
  script = "/etc/xen/scripts/qemu-ifup"
  downscript = "no"
  vhost = "on"

[device "net0"]
  driver = "virtio-net-pci"
  netdev = "hostnet0"
  mac = "02:16:3e:00:00:01"
  bus = "pci.6"
  addr = "0x0"
  host_mtu = "1500"

[device "pci.8"]
  driver = "pcie-root-port"
  port = "18"
  chassis = "8"
  bus = "pcie.0"
  multifunction = "on"
  addr = "0x8"

[netdev "hostnet1"]
  type = "tap"
  ifname = "nbu2x1"
  br = "br2"
  script = "/etc/xen/scripts/qemu-ifup"
  downscript = "no"
  vhost = "on"

[device "net1"]
  driver = "virtio-net-pci"
  netdev = "hostnet1"
  mac = "02:16:3e:00:00:02"
  bus = "pci.8"
  addr = "0x0"
  host_mtu = "1500"

[device "pci.7"]
  driver = "pcie-root-port"
  port = "17"
  chassis = "7"
  bus = "pcie.0"
  multifunction = "on"
  addr = "0x7"

[device "pcie-bridge.7"]
  driver = "pcie-pci-bridge"
  bus = "pci.7"
  addr = "0x0"

[device]
  driver = "vfio-pci"
  host = "06:00.0"
  bus = "pcie-bridge.7"
  addr = "0x1"

[device "pci.9"]
  driver = "pcie-root-port"
  port = "19"
  chassis = "9"
  bus = "pcie.0"
  multifunction = "on"
  addr = "0x9"

[device]
  driver = "vfio-pci"
  host = "00:15.0"
  bus = "pci.9"
  addr = "0x0"

[device]
  driver = "vfio-pci"
  host = "06:00.2"
  bus = "pcie-bridge.7"
  addr = "0x3"

[device]
  driver = "vfio-pci"
  host = "06:00.1"
  bus = "pcie-bridge.7"
  addr = "0x2"

[device "pci.5"]
  driver = "pcie-root-port"
  port = "15"
  chassis = "5"
  bus = "pcie.0"
  multifunction = "on"
  addr = "0x5"

[device]
  driver = "vfio-pci"
  host = "08:00.0"
  bus = "pci.5"
  addr = "0x0"
`
	g.Expect(buffer.String()).To(Equal(expectedConfig))

	// Try re-ordering functions of a multifunction device. This should be allowed.
	pciAssignments[0].netIntfOrder = 3
	pciAssignments[3].netIntfOrder = 2
	err = addrAllocator.allocate()
	g.Expect(err).ToNot(HaveOccurred())

	g.Expect(virtualNetworks[0].pciDeviceID).To(Equal(6))
	g.Expect(virtualNetworks[1].pciDeviceID).To(Equal(8))
	g.Expect(pciAssignments[0].pciBridgeID).To(Equal(7))
	g.Expect(pciAssignments[0].pciDeviceID).To(Equal(2)) // 1 -> 2
	g.Expect(pciAssignments[1].pciBridgeID).To(Equal(0))
	g.Expect(pciAssignments[1].pciDeviceID).To(Equal(9))
	g.Expect(pciAssignments[2].pciBridgeID).To(Equal(7))
	g.Expect(pciAssignments[2].pciDeviceID).To(Equal(3))
	g.Expect(pciAssignments[3].pciBridgeID).To(Equal(7))
	g.Expect(pciAssignments[3].pciDeviceID).To(Equal(1)) // 2 -> 1
	g.Expect(pciAssignments[4].pciBridgeID).To(Equal(0))
	g.Expect(pciAssignments[4].pciDeviceID).To(Equal(5))

	// Try to put virtual interface in-between functions of a multifunction device.
	// This should not be allowed.
	virtualNetworks[1].VifOrder = 3
	pciAssignments[0].netIntfOrder = 4

	err = addrAllocator.allocate()
	g.Expect(err).To(HaveOccurred())
	g.Expect(err.Error()).To(ContainSubstring("Invalid VIF nbu2x1 configuration: " +
		"user-defined network interface order disrupts the function sequence " +
		"of the multifunction PCI device 0000:06:00"))
	// Revert the invalid config change.
	virtualNetworks[1].VifOrder = 4
	pciAssignments[0].netIntfOrder = 3
	err = addrAllocator.allocate()
	g.Expect(err).ToNot(HaveOccurred())

	// Try to put PCI-passthrough network device in-between functions of a multifunction
	// device. This should not be allowed.
	pciAssignments[4].netIntfOrder = 3
	pciAssignments[0].netIntfOrder = 4

	err = addrAllocator.allocate()
	g.Expect(err).To(HaveOccurred())
	fmt.Println(err.Error())
	g.Expect(err.Error()).To(ContainSubstring("User-defined network interface order " +
		"disrupts the function sequence of the multifunction PCI devices 0000:06:00 and 0000:08:00"))
}
