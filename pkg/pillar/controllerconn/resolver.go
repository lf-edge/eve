// Copyright (c) 2017-2025 Zededa, Inc.
// SPDX-License-Identifier: Apache-2.0

// TODO: Write our own hostname resolver. The Go resolver will read at most 3 nameservers
// from /etc/resolv.conf:
//   https://github.com/golang/go/blob/go1.22.0/src/net/dnsconfig_unix.go#L51
// This is some historical /etc/resolv.conf limitation that Go decided to keep in their
// resolver implementation.
// This is a problem when we have multiple management ports, each with one or more DNS
// servers, together exceeding the limit of 3.
// For example:
// $ cat /etc/resolv.conf
//   # Generated by nim
//   # Do not edit
//   # From eth0
//   nameserver 10.156.8.4
//   nameserver 10.152.16.4
//   nameserver 10.152.16.6
//   # From wlan0
//   nameserver 192.168.1.1
//   # From wwan0
//   nameserver 172.26.38.1
//   options rotate
//   options attempts:5
//
// Go resolver will not pick up DNS servers for wlan0 and wwan0, resulting in
// "no DNS server available" errors for these two ports.

package controllerconn

import (
	"context"
	"fmt"
	"math"
	"net"
	"strings"
	"sync"
	"sync/atomic"
	"time"

	"github.com/lf-edge/eve-libs/nettrace"
	"github.com/lf-edge/eve/pkg/pillar/base"
	"github.com/lf-edge/eve/pkg/pillar/types"
	"github.com/lf-edge/eve/pkg/pillar/utils/netutils"
	"github.com/miekg/dns"
)

// ResolverWithLocalIP extends net.Resolver to allow to define local IP for DNS queries
// and a callback to skip some DNS servers. The callback is used by SendOnIntf to filter
// out DNS servers which should not be used for the given interface.
type ResolverWithLocalIP struct {
	log     *base.LogObject
	ifName  string
	localIP net.IP
	skipNs  nettrace.NameserverSelector
	// Allow DNS server proxy listening on a loopback IP address.
	// This is currently used only for unit testing purposes to support host operating
	// systems with DNS proxy (such as systemd with systemd-resolved).
	allowLoopbackDNS bool
	// Output flags used by DialerWithResolverCache to determine appropriate error
	// for failed Dial.
	dialRequested atomic.Bool
	dnsWasAvail   atomic.Bool
}

func (r *ResolverWithLocalIP) resolverDial(
	ctx context.Context, network, address string) (net.Conn, error) {
	if r.log != nil {
		r.log.Tracef("resolverDial %v %v", network, address)
	}
	r.dialRequested.Store(true)
	dnsHost, _, err := net.SplitHostPort(address)
	if err != nil {
		// No port in the address.
		dnsHost = address
	}
	dnsIP := net.ParseIP(dnsHost)
	if dnsIP == nil {
		return nil, fmt.Errorf("failed to parse DNS IP address '%s'", dnsHost)
	}
	if dnsIP.IsLoopback() && !r.allowLoopbackDNS {
		// 127.0.0.1:53 is tried by Golang resolver when resolv.conf does not contain
		// any nameservers (see defaultNS in net/dnsconfig_unix.go).
		// There is no point in looking for DNS server on the loopback interface on EVE.
		return nil, &types.DNSNotAvailError{IfName: r.ifName}
	}
	// Ensure the DNS server and local source IPs are of the same IP version.
	if r.localIP != nil && !netutils.SameIPVersions(r.localIP, dnsIP) {
		return nil, fmt.Errorf(
			"DNS server IP version (%v) does not match local IP version (%v)",
			dnsIP, r.localIP)
	}
	// Note that port number is not looked at by skipNs.
	if r.skipNs != nil {
		if skip, reason := r.skipNs(dnsIP, 0); skip {
			return nil, fmt.Errorf("skipped nameserver %v: %s", dnsIP, reason)
		}
	}
	r.dnsWasAvail.Store(true)
	if dnsIP.IsLoopback() {
		d := net.Dialer{}
		return d.DialContext(ctx, network, address)
	}
	switch network {
	case "udp", "udp4", "udp6":
		d := net.Dialer{LocalAddr: &net.UDPAddr{IP: r.localIP}}
		return d.DialContext(ctx, network, address)
	case "tcp", "tcp4", "tcp6":
		d := net.Dialer{LocalAddr: &net.TCPAddr{IP: r.localIP}}
		return d.DialContext(ctx, network, address)
	default:
		return nil, fmt.Errorf("unsupported address type: %v", network)
	}
}

// Return ResolverWithLocalIP functionality wrapped inside the standard net.Resolver type.
func (r *ResolverWithLocalIP) getNetResolver() *net.Resolver {
	return &net.Resolver{Dial: r.resolverDial, PreferGo: true, StrictErrors: false}
}

// DialerWithResolverCache provides DialContext function just like regular net.Dialer.
// The difference is that it will try to avoid DNS query if the target hostname IP is already
// resolved and stored in the cache.
// If dialing the cached IP fails, dialer will fall back to using regular dial, performing
// hostname IP resolution using available DNS servers.
type DialerWithResolverCache struct {
	log           *base.LogObject
	ifName        string
	localIP       net.IP
	skipNs        nettrace.NameserverSelector
	timeout       time.Duration
	resolverCache ResolverCacheFunc
	// Allow DNS server proxy listening on a loopback IP address.
	// This is currently used only for unit testing purposes to support host operating
	// systems with DNS proxy (such as systemd with systemd-resolved).
	allowLoopbackDNS bool
}

// DialContext : extends net.DialContext to first try dialing using a cached IP if available.
// Only if that fails, the standard DialContext is called.
func (d *DialerWithResolverCache) DialContext(
	ctx context.Context, network, address string) (net.Conn, error) {
	if d.log != nil {
		d.log.Tracef("DialContext %v %v", network, address)
	}
	resolver := ResolverWithLocalIP{
		log:              d.log,
		ifName:           d.ifName,
		localIP:          d.localIP,
		skipNs:           d.skipNs,
		allowLoopbackDNS: d.allowLoopbackDNS,
	}
	stdDialer := net.Dialer{
		Resolver:  resolver.getNetResolver(),
		LocalAddr: &net.TCPAddr{IP: d.localIP},
		Timeout:   d.timeout,
	}
	host, port, err := net.SplitHostPort(address)
	if err != nil {
		host = address
		port = ""
	}
	var cachedLookup []types.CachedIP
	if d.resolverCache != nil {
		cachedLookup = d.resolverCache(host)
	}
	for _, cachedEntry := range cachedLookup {
		if time.Now().After(cachedEntry.ValidUntil) {
			continue
		}
		if d.localIP != nil &&
			!netutils.SameIPVersions(cachedEntry.IPAddress, d.localIP) {
			continue
		}
		var addrWithIP string
		if port == "" {
			addrWithIP = cachedEntry.IPAddress.String()
		} else {
			addrWithIP = net.JoinHostPort(cachedEntry.IPAddress.String(), port)
		}
		conn, err := stdDialer.DialContext(ctx, network, addrWithIP)
		if err == nil {
			return conn, nil
		}
	}
	// Fall back to using the regular dialer.
	conn, err := stdDialer.DialContext(ctx, network, address)
	if err != nil {
		// Find out if dial failed because there was no DNS server available.
		// Even though SendOnIntf checks if there are any DNS servers available
		// for the given interface in DeviceNetworkStatus before using this dialer,
		// there might be a delay between config being written to /etc/resolv.conf
		// and the Golang resolver reloading it. More info about this can be found
		// in pillar/dpcmanager/verify.go, function verifyDPC.
		// Note that even with empty resolv.conf, Golang resolver will try at least
		// 127.0.0.1:53, so dialRequested=true means that hostname IP resolution was
		// needed (not using cached IP or /etc/hosts).
		// dnsWasAvail is set after filtering out DNS servers which are not valid
		// for the given interface (servers from other interfaces and the loopback IP).
		if resolver.dialRequested.Load() && !resolver.dnsWasAvail.Load() {
			err = &types.DNSNotAvailError{IfName: d.ifName}
		}
	}
	return conn, err
}

const (
	// DNSMaxParallelRequests is the maximum amount of parallel DNS requests
	DNSMaxParallelRequests     = 5
	maxTTLSec              int = 3600
	dnsTimeout                 = 30 * time.Second
)

// DNSResponse represents a response from a DNS server (A Record)
type DNSResponse struct {
	IP  net.IP
	TTL uint32
}

// ResolveWithSrcIPWithTimeout resolves a domain with a given dns server and source Ip within a time duration
func ResolveWithSrcIPWithTimeout(domain string, dnsServerIP net.IP, srcIP net.IP,
	timeout time.Duration) ([]DNSResponse, error) {
	var response []DNSResponse
	sourceUDPAddr := net.UDPAddr{IP: srcIP}
	dialer := net.Dialer{
		LocalAddr: &sourceUDPAddr,
		Timeout:   timeout,
	}
	dnsClient := dns.Client{Dialer: &dialer}
	msg := dns.Msg{}
	if !strings.HasSuffix(domain, ".") {
		domain = domain + "."
	}
	// Although we could issue two separate queries for A and AAAA records,
	// we currently limit the query type to match the IP version of the
	// source IP and the DNS server's address.
	// After all, there's no need to resolve an IPv6 address if the system
	// lacks a local IPv6 address â€” and the same applies to IPv4.
	ipv6 := srcIP.To4() == nil
	if ipv6 {
		msg.SetQuestion(domain, dns.TypeAAAA)
	} else {
		msg.SetQuestion(domain, dns.TypeA)
	}
	dnsClient.Timeout = time.Duration(dnsTimeout)
	reply, _, err := dnsClient.Exchange(&msg, net.JoinHostPort(dnsServerIP.String(), "53"))
	if err != nil {
		return response, fmt.Errorf("dns exchange failed: %v", err)
	}
	for _, answer := range reply.Answer {
		if aRecord, ok := answer.(*dns.A); ok {
			response = append(response, DNSResponse{
				IP:  aRecord.A,
				TTL: aRecord.Header().Ttl,
			})
		}
		if aaaaRecord, ok := answer.(*dns.AAAA); ok {
			response = append(response, DNSResponse{
				IP:  aaaaRecord.AAAA,
				TTL: aaaaRecord.Header().Ttl,
			})
		}
	}

	return response, nil
}

// ResolveWithSrcIP resolves a domain with a given dns server and source Ip
func ResolveWithSrcIP(domain string, dnsServerIP net.IP, srcIP net.IP) ([]DNSResponse, error) {
	return ResolveWithSrcIPWithTimeout(domain, dnsServerIP, srcIP, 0)
}

// ResolveWithSrcIPFunc defines type of the ResolveWithSrcIP function.
type ResolveWithSrcIPFunc func(
	domain string, dnsServerIP net.IP, srcIP net.IP) ([]DNSResponse, error)

type cachedDNSResponses struct {
	dnsResponses []DNSResponse
	validUntil   time.Time
}

type cachedDNSResponseKey struct {
	domain string
	srcIP  string
}

var resolveCache = map[cachedDNSResponseKey]cachedDNSResponses{}

// ResolveCacheWrap wraps around a resolve func (e.g. ResolveWithSrcIP) and caches DNS entries
func ResolveCacheWrap(
	resolve func(string, net.IP, net.IP) ([]DNSResponse, error)) ResolveWithSrcIPFunc {
	return func(domain string, dnsServerIP net.IP, srcIP net.IP) ([]DNSResponse, error) {

		cacheKey := cachedDNSResponseKey{
			domain: domain,
			srcIP:  srcIP.String(),
		}
		dnsResponses, found := resolveCache[cacheKey]
		if !found || !dnsResponses.validUntil.After(time.Now()) {
			dnsResponses, err := resolve(domain, dnsServerIP, srcIP)
			if err == nil {
				minValidUntil := uint32(math.MaxUint32)
				for _, dnsResponse := range dnsResponses {
					if dnsResponse.TTL < uint32(minValidUntil) {
						minValidUntil = dnsResponse.TTL
					}
				}
				validUntil := time.Now().Add(time.Duration(minValidUntil * uint32(time.Second)))
				resolveCache[cacheKey] = cachedDNSResponses{
					dnsResponses: dnsResponses,
					validUntil:   validUntil,
				}
			}

			return dnsResponses, err
		}

		return dnsResponses.dnsResponses, nil
	}
}

// ResolveWithPortsLambda resolves a domain by using source IPs and dns servers from DeviceNetworkStatus
// As a resolver func ResolveWithSrcIP can be used
func ResolveWithPortsLambda(domain string,
	dns types.DeviceNetworkStatus,
	resolve func(string, net.IP, net.IP) ([]DNSResponse, error)) ([]DNSResponse, []error) {

	quit := make(chan struct{})
	work := make(chan struct{}, DNSMaxParallelRequests)
	defer close(work)

	resolvedIPsChan := make(chan []DNSResponse, 1)
	defer close(resolvedIPsChan)

	countDNSRequests := 0
	var errs []error
	var errsMutex sync.Mutex
	var wg sync.WaitGroup
	var waitForIPv4, waitForIPv6 bool

	for _, port := range dns.Ports {
		if !port.IsL3Port || port.Cost > 0 {
			continue
		}

		var srcIPs []net.IP
		for _, addrInfo := range port.AddrInfoList {
			if addrInfo.Addr.IsGlobalUnicast() {
				srcIPs = append(srcIPs, addrInfo.Addr)
			}
		}

		for _, srcIP := range srcIPs {
			for _, dnsIP := range port.DNSServers {
				if !netutils.SameIPVersions(srcIP, dnsIP) {
					continue
				}
				if srcIP.To4() != nil {
					waitForIPv4 = true
				} else {
					waitForIPv6 = true
				}
				wg.Add(1)
				dnsIPCopy := make(net.IP, len(dnsIP))
				copy(dnsIPCopy, dnsIP)
				srcIPCopy := make(net.IP, len(srcIP))
				copy(srcIPCopy, srcIP)
				countDNSRequests++
				go func(dnsIP, srcIP net.IP) {
					defer func() {
						wg.Done()
						<-work
					}()
					// if writable, means less than dnsMaxParallelRequests
					// goroutines are currently running
					work <- struct{}{}

					select {
					case <-quit:
						// will return in case the quit chan has been closed,
						// meaning another dns server already resolved the IP
						return
					default:
						// do not wait for receiving a quit
					}
					response, err := resolve(domain, dnsIP, srcIP)
					if err != nil {
						errsMutex.Lock()
						defer errsMutex.Unlock()
						errs = append(errs, err)
					}
					if response != nil && len(response) > 0 {
						select {
						case resolvedIPsChan <- response:
						case <-quit:
						}
					}
				}(dnsIPCopy, srcIPCopy)
			}
		}
	}

	wgChan := make(chan struct{})

	go func() {
		wg.Wait()
		close(wgChan)
	}()

	defer func() {
		close(quit)
		<-wgChan
	}()

	var responses []DNSResponse
	processResponses := func(dnsResponses []DNSResponse) {
		for _, dnsResp := range dnsResponses {
			if dnsResp.IP.To4() != nil {
				waitForIPv4 = false
			} else {
				waitForIPv6 = false
			}
			// Avoid duplicates.
			var duplicate bool
			for i := range responses {
				if responses[i].IP.Equal(dnsResp.IP) {
					duplicate = true
					break
				}
			}
			if !duplicate {
				responses = append(responses, dnsResp)
			}
		}
	}

	for {
		select {
		case <-wgChan:
			if countDNSRequests == 0 {
				// fallback in case no resolver is configured
				ips, err := net.LookupIP(domain)
				if err != nil {
					return nil, append(errs, fmt.Errorf("fallback resolver failed: %+v", err))
				}
				for _, ip := range ips {
					responses = append(responses, DNSResponse{
						IP:  ip,
						TTL: uint32(maxTTLSec),
					})
				}
			}
			// Make sure we do not leave any DNS response unprocessed.
			// (at most one channel item can be buffered in resolvedIPsChan).
			select {
			case dnsResponses := <-resolvedIPsChan:
				processResponses(dnsResponses)
			default:
			}
			if len(responses) > 0 {
				return responses, nil
			}
			return nil, errs
		case dnsResponses := <-resolvedIPsChan:
			processResponses(dnsResponses)
			if !waitForIPv4 && !waitForIPv6 {
				return responses, nil
			}
		}
	}

}
