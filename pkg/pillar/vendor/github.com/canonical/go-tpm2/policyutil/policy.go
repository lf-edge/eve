// Copyright 2023 Canonical Ltd.
// Licensed under the LGPLv3 with static-linking exception.
// See LICENCE file for details.

package policyutil

import (
	"crypto"
	"crypto/sha256"
	"errors"
	"fmt"
	"io"
	"reflect"

	"github.com/canonical/go-tpm2"
	"github.com/canonical/go-tpm2/mu"
)

type paramKey [sha256.Size]byte

func policyParamKey(authName tpm2.Name, policyRef tpm2.Nonce) paramKey {
	h := crypto.SHA256.New()
	h.Write(authName)
	h.Write(policyRef)

	var key paramKey
	copy(key[:], h.Sum(nil))
	return key
}

// PolicyTicket corresponds to a ticket generated from a TPM2_PolicySigned or TPM2_PolicySecret
// assertion and is returned by [Policy.Execute]. Generated tickets can be supplied to
// [Policy.Execute] in the future in order to satisfy these assertions as long as they haven't
// expired.
type PolicyTicket struct {
	AuthName  tpm2.Name    // The name of the auth object associated with the corresponding assertion
	PolicyRef tpm2.Nonce   // The policy ref of the corresponding assertion
	CpHash    tpm2.Digest  // The cpHash supplied to the assertion that generated this ticket
	Timeout   tpm2.Timeout // The timeout returned by the assertion that generated this ticket

	// Ticket is the actual ticket returned by the TPM for the assertion that generated this ticket.
	// The Tag field indicates whether this was generated by TPM2_PolicySigned or TPM2_PolicySecret.
	Ticket *tpm2.TkAuth
}

// PolicySecretParams provides a way for an application to customize the cpHash and expiration
// arguments of a TPM2_PolicySecret assertion with the specified reference and for a resource
// with the specified name. These parameters aren't part of the policy because they aren't
// cryptographically bound to the policy digest and can be modified.
type PolicySecretParams struct {
	AuthName  tpm2.Name  // The name of the auth object associated with the corresponding TPM2_PolicySecret assertion
	PolicyRef tpm2.Nonce // The policy ref of the corresponding assertion
	CpHash    CpHash     // The command parameters to restrict the session usage to

	// Expiration specifies a timeout based on the absolute value of this field in seconds, after
	// which the authorization will expire. The timeout is measured from the time that the most
	// recent TPM nonce was generated for the session. This can be used to request a ticket that
	// can be used in a subsequent policy execution by specifying a negative value, in which case
	// this field and the CpHash field restrict the validity period and scope of the returned
	// ticket.
	Expiration int32
}

// PolicyExecuteParams contains parameters that are useful for executing a policy.
type PolicyExecuteParams struct {
	SecretParams   []*PolicySecretParams  // Parameters for TPM2_PolicySecret assertions
	Tickets        []*PolicyTicket        // Tickets for TPM2_PolicySecret and TPM2_PolicySigned assertions
	Authorizations []*PolicyAuthorization // Authorizations for TPM2_PolicySigned assertions
}

// PolicyExecuteHelper allows an application to customize the execution of a policy.
type PolicyExecuteHelper interface {
	// Load requests that a resource with the specified name is loaded into the TPM if it
	// needs to be, and a resource context corresponding to it returned.
	//
	// If the returned context corresponds to a transient object, it will be flushed automatically.
	//
	// This will not be called for permanent resources or PCRs.
	//
	// This is required to support TPM2_PolicySecret.
	Load(name tpm2.Name) (tpm2.ResourceContext, error)

	// Authorize requests that the supplied context is prepared for use with the user auth role for
	// the corresponding resource. If the user auth role requires knowledge of the authorization
	// value, this should be set by the implementation. The implementation can also return an optional
	// session to use for authorization. If no session is returned, passphrase auth is used.
	//
	// This is required to support TPM2_PolicyNV and TPM2_PolicySecret.
	Authorize(resource tpm2.ResourceContext) (tpm2.SessionContext, error)

	// SignAuthorization requests a signed authorization for a TPM2_PolicySigned assertion.
	// The authorization must be signed by the private key associated with authKey and must
	// contain the specified policyRef.
	SignAuthorization(authKey tpm2.ResourceContext, policyRef tpm2.Nonce) (*PolicyAuthorization, error)
}

type policySession interface {
	HashAlg() tpm2.HashAlgorithmId

	PolicyNV(auth, index tpm2.ResourceContext, operandB tpm2.Operand, offset uint16, operation tpm2.ArithmeticOp, authAuthSession tpm2.SessionContext) error
	PolicySecret(authObject tpm2.ResourceContext, cpHashA tpm2.Digest, policyRef tpm2.Nonce, expiration int32, authObjectAuthSession tpm2.SessionContext) (tpm2.Timeout, *tpm2.TkAuth, error)
	PolicySigned(authKey tpm2.ResourceContext, includeNonceTPM bool, cpHashA tpm2.Digest, policyRef tpm2.Nonce, expiration int32, auth *tpm2.Signature) (tpm2.Timeout, *tpm2.TkAuth, error)
	PolicyAuthorize(approvedPolicy tpm2.Digest, policyRef tpm2.Nonce, keySign tpm2.Name, verified *tpm2.TkVerified) error
	PolicyAuthValue() error
	PolicyCommandCode(code tpm2.CommandCode) error
	PolicyCounterTimer(operandB tpm2.Operand, offset uint16, operation tpm2.ArithmeticOp) error
	PolicyCpHash(cpHashA tpm2.Digest) error
	PolicyNameHash(nameHash tpm2.Digest) error
	PolicyOR(pHashList tpm2.DigestList) error
	PolicyTicket(timeout tpm2.Timeout, cpHashA tpm2.Digest, policyRef tpm2.Nonce, authName tpm2.Name, ticket *tpm2.TkAuth) error
	PolicyPCR(pcrDigest tpm2.Digest, pcrs tpm2.PCRSelectionList) error
	PolicyDuplicationSelect(objectName, newParentName tpm2.Name, includeObject bool) error
	PolicyPassword() error
	PolicyNvWritten(writtenSet bool) error
}

type realPolicySession struct {
	tpm           *tpm2.TPMContext
	policySession tpm2.SessionContext
	helper        PolicyExecuteHelper
	sessions      []tpm2.SessionContext
}

func newRealPolicySession(tpm *tpm2.TPMContext, policySession tpm2.SessionContext, helper PolicyExecuteHelper, sessions ...tpm2.SessionContext) *realPolicySession {
	return &realPolicySession{
		tpm:           tpm,
		policySession: policySession,
		helper:        helper,
		sessions:      sessions}
}

func (s *realPolicySession) HashAlg() tpm2.HashAlgorithmId {
	return s.policySession.HashAlg()
}

func (s *realPolicySession) PolicyNV(auth, index tpm2.ResourceContext, operandB tpm2.Operand, offset uint16, operation tpm2.ArithmeticOp, authAuthSession tpm2.SessionContext) error {
	return s.tpm.PolicyNV(auth, index, s.policySession, operandB, offset, operation, authAuthSession, s.sessions...)
}

func (s *realPolicySession) PolicySecret(authObject tpm2.ResourceContext, cpHashA tpm2.Digest, policyRef tpm2.Nonce, expiration int32, authObjectAuthSession tpm2.SessionContext) (tpm2.Timeout, *tpm2.TkAuth, error) {
	return s.tpm.PolicySecret(authObject, s.policySession, cpHashA, policyRef, expiration, authObjectAuthSession, s.sessions...)
}

func (s *realPolicySession) PolicySigned(authKey tpm2.ResourceContext, includeNonceTPM bool, cpHashA tpm2.Digest, policyRef tpm2.Nonce, expiration int32, auth *tpm2.Signature) (tpm2.Timeout, *tpm2.TkAuth, error) {
	return s.tpm.PolicySigned(authKey, s.policySession, includeNonceTPM, cpHashA, policyRef, expiration, auth, s.sessions...)
}

func (s *realPolicySession) PolicyAuthorize(approvedPolicy tpm2.Digest, policyRef tpm2.Nonce, keySign tpm2.Name, verified *tpm2.TkVerified) error {
	return s.tpm.PolicyAuthorize(s.policySession, approvedPolicy, policyRef, keySign, verified, s.sessions...)
}

func (s *realPolicySession) PolicyAuthValue() error {
	return s.tpm.PolicyAuthValue(s.policySession, s.sessions...)
}

func (s *realPolicySession) PolicyCommandCode(code tpm2.CommandCode) error {
	return s.tpm.PolicyCommandCode(s.policySession, code, s.sessions...)
}

func (s *realPolicySession) PolicyCounterTimer(operandB tpm2.Operand, offset uint16, operation tpm2.ArithmeticOp) error {
	return s.tpm.PolicyCounterTimer(s.policySession, operandB, offset, operation, s.sessions...)
}

func (s *realPolicySession) PolicyCpHash(cpHashA tpm2.Digest) error {
	return s.tpm.PolicyCpHash(s.policySession, cpHashA, s.sessions...)
}

func (s *realPolicySession) PolicyNameHash(nameHash tpm2.Digest) error {
	return s.tpm.PolicyNameHash(s.policySession, nameHash, s.sessions...)
}

func (s *realPolicySession) PolicyOR(pHashList tpm2.DigestList) error {
	return s.tpm.PolicyOR(s.policySession, pHashList, s.sessions...)
}

func (s *realPolicySession) PolicyTicket(timeout tpm2.Timeout, cpHashA tpm2.Digest, policyRef tpm2.Nonce, authName tpm2.Name, ticket *tpm2.TkAuth) error {
	return s.tpm.PolicyTicket(s.policySession, timeout, cpHashA, policyRef, authName, ticket, s.sessions...)
}

func (s *realPolicySession) PolicyPCR(pcrDigest tpm2.Digest, pcrs tpm2.PCRSelectionList) error {
	return s.tpm.PolicyPCR(s.policySession, pcrDigest, pcrs, s.sessions...)
}

func (s *realPolicySession) PolicyDuplicationSelect(objectName, newParentName tpm2.Name, includeObject bool) error {
	return s.tpm.PolicyDuplicationSelect(s.policySession, objectName, newParentName, includeObject, s.sessions...)
}

func (s *realPolicySession) PolicyPassword() error {
	return s.tpm.PolicyPassword(s.policySession, s.sessions...)
}

func (s *realPolicySession) PolicyNvWritten(writtenSet bool) error {
	return s.tpm.PolicyNvWritten(s.policySession, writtenSet, s.sessions...)
}

type policyResourceContext interface {
	resource() tpm2.ResourceContext
	flush() error
}

type policyResourceContextFlushable struct {
	rc  tpm2.ResourceContext
	tpm *tpm2.TPMContext
}

func newPolicyResourceContextFlushable(tpm *tpm2.TPMContext, context tpm2.ResourceContext) policyResourceContext {
	return &policyResourceContextFlushable{rc: context, tpm: tpm}
}

func (r *policyResourceContextFlushable) resource() tpm2.ResourceContext {
	return r.rc
}

func (r *policyResourceContextFlushable) flush() error {
	return r.tpm.FlushContext(r.rc)
}

type policyResourceContextNoFlush struct {
	rc tpm2.ResourceContext
}

func newPolicyResourceContextNonFlushable(context tpm2.ResourceContext) policyResourceContext {
	return &policyResourceContextNoFlush{rc: context}
}

func (r *policyResourceContextNoFlush) resource() tpm2.ResourceContext {
	return r.rc
}

func (r *policyResourceContextNoFlush) flush() error {
	return nil
}

type policyRunContext interface {
	session() policySession

	secretParams(authName tpm2.Name, policyRef tpm2.Nonce) *PolicySecretParams
	signAuthorization(authKey tpm2.ResourceContext, policyRef tpm2.Nonce) (*PolicyAuthorization, error)
	ticket(authName tpm2.Name, policyRef tpm2.Nonce) *PolicyTicket

	loadResourceHandle(handle tpm2.Handle) (tpm2.ResourceContext, error)
	loadResourceName(name tpm2.Name) (policyResourceContext, error)
	loadExternalResource(pub *tpm2.Public) (policyResourceContext, error)

	nvReadPublic(context tpm2.HandleContext) (*tpm2.NVPublic, error)
	authorize(context tpm2.ResourceContext) (tpm2.SessionContext, error)

	usedTicket(ticket *PolicyTicket)
}

type policyElementRunner interface {
	run(context policyRunContext) error
}

type taggedHash struct {
	HashAlg tpm2.HashAlgorithmId
	Digest  tpm2.Digest
}

func (h taggedHash) Marshal(w io.Writer) error {
	ta := tpm2.MakeTaggedHash(h.HashAlg, h.Digest)
	_, err := mu.MarshalToWriter(w, ta)
	return err
}

func (h *taggedHash) Unmarshal(r io.Reader) error {
	var ta tpm2.TaggedHash
	if _, err := mu.UnmarshalFromReader(r, &ta); err != nil {
		return err
	}

	if ta.HashAlg != tpm2.HashAlgorithmNull && !ta.HashAlg.IsValid() {
		return errors.New("invalid digest algorithm")
	}

	*h = taggedHash{
		HashAlg: ta.HashAlg,
		Digest:  ta.Digest()}
	return nil
}

type taggedHashList []taggedHash

type policyNV struct {
	NvIndex   tpm2.Handle
	OperandB  tpm2.Operand
	Offset    uint16
	Operation tpm2.ArithmeticOp
}

func (e *policyNV) run(context policyRunContext) error {
	nvIndex, err := context.loadResourceHandle(e.NvIndex)
	if err != nil {
		return fmt.Errorf("cannot create context for PolicyNV index: %w", err)
	}

	pub, err := context.nvReadPublic(nvIndex)
	if err != nil {
		return fmt.Errorf("cannot read NV public area for PolicyNV assertion: %w", err)
	}

	auth := nvIndex
	switch {
	default:
	case pub.Attrs&tpm2.AttrNVOwnerRead != 0:
		auth, err = context.loadResourceHandle(tpm2.HandleOwner)
	case pub.Attrs&tpm2.AttrNVPPRead != 0:
		auth, err = context.loadResourceHandle(tpm2.HandlePlatform)
	}
	if err != nil {
		return fmt.Errorf("cannot create context for PolicyNV auth: %w", err)
	}

	authContextAuthSession, err := context.authorize(auth)
	if err != nil {
		return fmt.Errorf("cannot authorize auth object for PolicyNV assertion: %w", err)
	}
	defer func() {
		if authContextAuthSession == nil || err == nil {
			return
		}
		// In the event of an error, flush a session that doesn't have AttrContinueSession set.
		if authContextAuthSession.Attrs()&tpm2.AttrContinueSession != 0 {
			return
		}
		//s.tpm.FlushContext(authContextAuthSession)
	}()

	return context.session().PolicyNV(auth, nvIndex, e.OperandB, e.Offset, e.Operation, authContextAuthSession)
}

type policySecret struct {
	AuthObjectName tpm2.Name
	PolicyRef      tpm2.Nonce
}

func (e *policySecret) run(context policyRunContext) error {
	if ticket := context.ticket(e.AuthObjectName, e.PolicyRef); ticket != nil {
		err := context.session().PolicyTicket(ticket.Timeout, ticket.CpHash, ticket.PolicyRef, ticket.AuthName, ticket.Ticket)
		switch {
		case tpm2.IsTPMParameterError(err, tpm2.ErrorExpired, tpm2.CommandPolicyTicket, 1):
			// The ticket has expired - ignore this and fall through to PolicySecret
		case tpm2.IsTPMParameterError(err, tpm2.ErrorTicket, tpm2.CommandPolicyTicket, 5):
			// The ticket is invalid - ignore this and fall through to PolicySecret
		case err != nil:
			return err
		default:
			context.usedTicket(ticket)
			return nil
		}
	}

	params := context.secretParams(e.AuthObjectName, e.PolicyRef)
	if params == nil {
		var nilParams PolicySecretParams
		params = &nilParams
	}

	var cpHashA tpm2.Digest
	if params.CpHash != nil {
		var err error
		cpHashA, err = params.CpHash.Digest(context.session().HashAlg())
		if err != nil {
			return fmt.Errorf("cannot obtain PolicySecret cpHashA: %w", err)
		}
	}

	authObject, err := context.loadResourceName(e.AuthObjectName)
	if err != nil {
		return fmt.Errorf("cannot create context for PolicySecret auth object: %w", err)
	}
	defer authObject.flush()

	authObjectAuthSession, err := context.authorize(authObject.resource())
	if err != nil {
		return fmt.Errorf("cannot authorize object for PolicySecret assertion: %w", err)
	}
	defer func() {
		if authObjectAuthSession == nil || err == nil {
			return
		}
		// In the event of an error, flush a session that doesn't have AttrContinueSession set.
		if authObjectAuthSession.Attrs()&tpm2.AttrContinueSession != 0 {
			return
		}
		//s.tpm.FlushContext(authObjectAuthSession)
	}()

	timeout, ticket, err := context.session().PolicySecret(authObject.resource(), cpHashA, e.PolicyRef, params.Expiration, authObjectAuthSession)
	if err != nil {
		return err
	}

	context.usedTicket(&PolicyTicket{
		AuthName:  e.AuthObjectName,
		PolicyRef: e.PolicyRef,
		CpHash:    cpHashA,
		Timeout:   timeout,
		Ticket:    ticket})
	return nil
}

type policySigned struct {
	AuthKey   *tpm2.Public
	PolicyRef tpm2.Nonce
}

func (e *policySigned) run(context policyRunContext) error {
	authKey, err := context.loadExternalResource(e.AuthKey)
	if err != nil {
		return fmt.Errorf("cannot create context for PolicySigned auth key: %w", err)
	}
	defer authKey.flush()

	if ticket := context.ticket(authKey.resource().Name(), e.PolicyRef); ticket != nil {
		err := context.session().PolicyTicket(ticket.Timeout, ticket.CpHash, ticket.PolicyRef, ticket.AuthName, ticket.Ticket)
		switch {
		case tpm2.IsTPMParameterError(err, tpm2.ErrorExpired, tpm2.CommandPolicyTicket, 1):
			// The ticket has expired - ignore this and fall through to PolicySigned
		case tpm2.IsTPMParameterError(err, tpm2.ErrorTicket, tpm2.CommandPolicyTicket, 5):
			// The ticket is invalid - ignore this and fall through to PolicySigned
		case err != nil:
			return err
		default:
			context.usedTicket(ticket)
			return nil
		}
	}

	auth, err := context.signAuthorization(authKey.resource(), e.PolicyRef)
	if err != nil {
		return fmt.Errorf("cannot obtain signed authorization for PolicySigned assertion: %w", err)
	}

	includeNonceTPM := false
	if len(auth.NonceTPM) > 0 {
		includeNonceTPM = true
	}

	timeout, ticket, err := context.session().PolicySigned(authKey.resource(), includeNonceTPM, auth.CpHash, e.PolicyRef, auth.Expiration, auth.Signature)
	if err != nil {
		return err
	}

	context.usedTicket(&PolicyTicket{
		AuthName:  authKey.resource().Name(),
		PolicyRef: e.PolicyRef,
		CpHash:    auth.CpHash,
		Timeout:   timeout,
		Ticket:    ticket})
	return nil
}

type policyAuthValue struct{}

func (*policyAuthValue) run(context policyRunContext) error {
	return context.session().PolicyAuthValue()
}

type policyCommandCode struct {
	CommandCode tpm2.CommandCode
}

func (e *policyCommandCode) run(context policyRunContext) error {
	return context.session().PolicyCommandCode(e.CommandCode)
}

type policyCounterTimer struct {
	OperandB  tpm2.Operand
	Offset    uint16
	Operation tpm2.ArithmeticOp
}

func (e *policyCounterTimer) run(context policyRunContext) error {
	return context.session().PolicyCounterTimer(e.OperandB, e.Offset, e.Operation)
}

type policyCpHash struct {
	Digests taggedHashList
}

func (e *policyCpHash) run(context policyRunContext) error {
	var cpHashA tpm2.Digest
	for _, digest := range e.Digests {
		if digest.HashAlg != context.session().HashAlg() {
			continue
		}
		cpHashA = digest.Digest
		break
	}
	if cpHashA == nil {
		return errors.New("no digest for session algorithm available for PolicyCpHash assertion")
	}
	return context.session().PolicyCpHash(cpHashA)
}

type policyNameHash struct {
	Digests taggedHashList
}

func (e *policyNameHash) run(context policyRunContext) error {
	var nameHash tpm2.Digest
	for _, digest := range e.Digests {
		if digest.HashAlg != context.session().HashAlg() {
			continue
		}
		nameHash = digest.Digest
		break
	}
	if nameHash == nil {
		return errors.New("no digest for session algorithm available for PolicyNameHash assertion")
	}
	return context.session().PolicyNameHash(nameHash)
}

type pcrValue struct {
	PCR    tpm2.Handle
	Digest taggedHash
}

type pcrValueList []pcrValue

type policyPCR struct {
	PCRs pcrValueList
}

func (e *policyPCR) run(context policyRunContext) error {
	values := make(tpm2.PCRValues)
	for i, value := range e.PCRs {
		if value.PCR.Type() != tpm2.HandleTypePCR {
			return fmt.Errorf("invalid PCR handle at index %d for PolicyPCR assertion", i)
		}
		if err := values.SetValue(value.Digest.HashAlg, int(value.PCR), value.Digest.Digest); err != nil {
			return fmt.Errorf("invalid PCR value at index %d for PolicyPCR assertion: %w", i, err)
		}
	}
	pcrs, pcrDigest, err := ComputePCRDigestFromAllValues(context.session().HashAlg(), values)
	if err != nil {
		return fmt.Errorf("cannot compute PCR digest for PolicyPCR assertion: %w", err)
	}
	return context.session().PolicyPCR(pcrDigest, pcrs)
}

type policyDuplicationSelect struct {
	Object        tpm2.Name
	NewParent     tpm2.Name
	IncludeObject bool
}

func (e *policyDuplicationSelect) run(context policyRunContext) error {
	return context.session().PolicyDuplicationSelect(e.Object, e.NewParent, e.IncludeObject)
}

type policyPassword struct{}

func (*policyPassword) run(context policyRunContext) error {
	return context.session().PolicyPassword()
}

type policyNvWritten struct {
	WrittenSet bool
}

func (e *policyNvWritten) run(context policyRunContext) error {
	return context.session().PolicyNvWritten(e.WrittenSet)
}

type policyElementDetails struct {
	NV                *policyNV
	Secret            *policySecret
	Signed            *policySigned
	AuthValue         *policyAuthValue
	CommandCode       *policyCommandCode
	CounterTimer      *policyCounterTimer
	CpHash            *policyCpHash
	NameHash          *policyNameHash
	PCR               *policyPCR
	DuplicationSelect *policyDuplicationSelect
	Password          *policyPassword
	NvWritten         *policyNvWritten
}

func (d *policyElementDetails) Select(selector reflect.Value) interface{} {
	switch selector.Interface().(tpm2.CommandCode) {
	case tpm2.CommandPolicyNV:
		return &d.NV
	case tpm2.CommandPolicySecret:
		return &d.Secret
	case tpm2.CommandPolicySigned:
		return &d.Signed
	case tpm2.CommandPolicyAuthValue:
		return &d.AuthValue
	case tpm2.CommandPolicyCommandCode:
		return &d.CommandCode
	case tpm2.CommandPolicyCounterTimer:
		return &d.CounterTimer
	case tpm2.CommandPolicyCpHash:
		return &d.CpHash
	case tpm2.CommandPolicyNameHash:
		return &d.NameHash
	case tpm2.CommandPolicyPCR:
		return &d.PCR
	case tpm2.CommandPolicyDuplicationSelect:
		return &d.DuplicationSelect
	case tpm2.CommandPolicyPassword:
		return &d.Password
	case tpm2.CommandPolicyNvWritten:
		return &d.NvWritten
	default:
		return nil
	}
}

type policyElement struct {
	Type    tpm2.CommandCode
	Details *policyElementDetails
}

func (e *policyElement) runner() policyElementRunner {
	switch e.Type {
	case tpm2.CommandPolicyNV:
		return e.Details.NV
	case tpm2.CommandPolicySecret:
		return e.Details.Secret
	case tpm2.CommandPolicySigned:
		return e.Details.Signed
	case tpm2.CommandPolicyAuthValue:
		return e.Details.AuthValue
	case tpm2.CommandPolicyCommandCode:
		return e.Details.CommandCode
	case tpm2.CommandPolicyCounterTimer:
		return e.Details.CounterTimer
	case tpm2.CommandPolicyCpHash:
		return e.Details.CpHash
	case tpm2.CommandPolicyNameHash:
		return e.Details.NameHash
	case tpm2.CommandPolicyPCR:
		return e.Details.PCR
	case tpm2.CommandPolicyDuplicationSelect:
		return e.Details.DuplicationSelect
	case tpm2.CommandPolicyPassword:
		return e.Details.Password
	case tpm2.CommandPolicyNvWritten:
		return e.Details.NvWritten
	default:
		panic("invalid type")
	}
}

type policyElements []*policyElement

type policy struct {
	Policy policyElements
}

// Policy corresponds to an authorization policy. It can be serialized with
// [github.com/canonical/go-tpm2/mu].
type Policy struct {
	policy policy
}

// Marshal implements [mu.CustomMarshaller.Marshal].
func (p Policy) Marshal(w io.Writer) error {
	_, err := mu.MarshalToWriter(w, p.policy)
	return err
}

// Unmarshal implements [mu.CustomMarshaller.Unarshal].
func (p *Policy) Unmarshal(r io.Reader) error {
	_, err := mu.UnmarshalFromReader(r, &p.policy)
	return err
}

type policyExecuteContext struct {
	tpm              *tpm2.TPMContext
	policySession    *realPolicySession
	secretParamsMap  map[paramKey]*PolicySecretParams
	ticketMap        map[paramKey]*PolicyTicket
	authorizationMap map[paramKey]*PolicyAuthorization
	helper           PolicyExecuteHelper
	sessions         []tpm2.SessionContext

	elements []policyElementRunner

	usedTickets        map[paramKey]*PolicyTicket
	usedAuthorizations map[paramKey]*PolicyAuthorization
}

func (c *policyExecuteContext) session() policySession {
	return c.policySession
}

func (c *policyExecuteContext) secretParams(authName tpm2.Name, policyRef tpm2.Nonce) *PolicySecretParams {
	return c.secretParamsMap[policyParamKey(authName, policyRef)]
}

func (c *policyExecuteContext) signAuthorization(authKey tpm2.ResourceContext, policyRef tpm2.Nonce) (*PolicyAuthorization, error) {
	key := policyParamKey(authKey.Name(), policyRef)

	auth, found := c.authorizationMap[key]
	if found {
		c.usedAuthorizations[key] = auth
		return auth, nil
	}

	if c.helper == nil {
		return nil, errors.New("no helper")
	}

	auth, err := c.helper.SignAuthorization(authKey, policyRef)
	if err != nil {
		return nil, err
	}
	c.authorizationMap[key] = auth
	c.usedAuthorizations[key] = auth
	return auth, nil
}

func (c *policyExecuteContext) ticket(authName tpm2.Name, policyRef tpm2.Nonce) *PolicyTicket {
	return c.ticketMap[policyParamKey(authName, policyRef)]
}

func (c *policyExecuteContext) loadResourceHandle(handle tpm2.Handle) (tpm2.ResourceContext, error) {
	switch handle.Type() {
	case tpm2.HandleTypePCR, tpm2.HandleTypePermanent:
		return c.policySession.tpm.GetPermanentContext(handle), nil
	case tpm2.HandleTypeNVIndex:
		return c.policySession.tpm.NewResourceContext(handle, c.policySession.sessions...)
	default:
		return nil, errors.New("invalid handle type")
	}
}

func (c *policyExecuteContext) loadResourceName(name tpm2.Name) (policyResourceContext, error) {
	if !name.IsValid() {
		return nil, errors.New("invalid name")
	}
	if name.Type() == tpm2.NameTypeHandle && (name.Handle().Type() == tpm2.HandleTypePCR || name.Handle().Type() == tpm2.HandleTypePermanent) {
		return newPolicyResourceContextNonFlushable(c.policySession.tpm.GetPermanentContext(name.Handle())), nil
	}

	if c.helper == nil {
		return nil, errors.New("cannot load resource: no helper")
	}

	resource, err := c.helper.Load(name)
	if err != nil {
		return nil, fmt.Errorf("cannot load resource: %w", err)
	}

	switch resource.Handle().Type() {
	case tpm2.HandleTypeNVIndex, tpm2.HandleTypePersistent:
		return newPolicyResourceContextNonFlushable(resource), nil
	default:
		return newPolicyResourceContextFlushable(c.policySession.tpm, resource), nil
	}
}

func (c *policyExecuteContext) loadExternalResource(public *tpm2.Public) (policyResourceContext, error) {
	rc, err := c.policySession.tpm.LoadExternal(nil, public, tpm2.HandleOwner, c.policySession.sessions...)
	if err != nil {
		return nil, err
	}
	return newPolicyResourceContextFlushable(c.policySession.tpm, rc), nil
}

func (c *policyExecuteContext) nvReadPublic(context tpm2.HandleContext) (*tpm2.NVPublic, error) {
	pub, _, err := c.policySession.tpm.NVReadPublic(context)
	return pub, err
}

func (c *policyExecuteContext) authorize(context tpm2.ResourceContext) (tpm2.SessionContext, error) {
	if c.helper == nil {
		return nil, errors.New("no helper")
	}
	return c.helper.Authorize(context)
}

func (c *policyExecuteContext) usedTicket(ticket *PolicyTicket) {
	key := policyParamKey(ticket.AuthName, ticket.PolicyRef)
	c.ticketMap[key] = ticket
	c.usedTickets[key] = ticket
}

// Execute runs this policy using the supplied TPM context and on the supplied policy session.
//
// The caller may supply an implementation of PolicyExecuteHelper to assist with the execution
// of this policy - some policy assertions require this.
//
// The caller may supply additional parameters via the PolicyExecuteParams struct. This can contain
// parameters for TPM2_PolicySecret assertions, signed authorizations for TPM2_PolicySigned
// assertions, or tickets to satisfy TPM2_PolicySecret or TPM2_PolicySigned assertions. Each of
// these parameters are associated with a policy assertion by a name and policy reference.
//
// On success, the supplied policy session may be used for authorization in a context that requires
// that this policy is satisfied. It will also return a list of tickets generated by any assertions,
// and a list of policy authorizations that were used if they can be used in a subsequent policy
// execution.
func (p *Policy) Execute(tpm *tpm2.TPMContext, policySession tpm2.SessionContext, params *PolicyExecuteParams, helper PolicyExecuteHelper, sessions ...tpm2.SessionContext) ([]*PolicyTicket, []*PolicyAuthorization, error) {
	if params == nil {
		params = new(PolicyExecuteParams)
	}

	context := &policyExecuteContext{
		policySession:      newRealPolicySession(tpm, policySession, helper, sessions...),
		secretParamsMap:    make(map[paramKey]*PolicySecretParams),
		ticketMap:          make(map[paramKey]*PolicyTicket),
		authorizationMap:   make(map[paramKey]*PolicyAuthorization),
		helper:             helper,
		elements:           make([]policyElementRunner, 0, len(p.policy.Policy)),
		usedTickets:        make(map[paramKey]*PolicyTicket),
		usedAuthorizations: make(map[paramKey]*PolicyAuthorization)}
	for _, param := range params.SecretParams {
		context.secretParamsMap[policyParamKey(param.AuthName, param.PolicyRef)] = param
	}
	for _, ticket := range params.Tickets {
		context.ticketMap[policyParamKey(ticket.AuthName, ticket.PolicyRef)] = ticket
	}
	for _, auth := range params.Authorizations {
		context.authorizationMap[policyParamKey(auth.AuthName, auth.PolicyRef)] = auth
	}
	for _, element := range p.policy.Policy {
		context.elements = append(context.elements, element.runner())
	}

	for len(context.elements) > 0 {
		element := context.elements[0]
		context.elements = context.elements[1:]

		if err := element.run(context); err != nil {
			return nil, nil, err
		}
	}

	var tickets []*PolicyTicket
	for _, ticket := range context.usedTickets {
		if ticket.Ticket.Hierarchy == tpm2.HandleNull && len(ticket.Ticket.Digest) == 0 {
			// skip null tickets
			continue
		}
		tickets = append(tickets, ticket)
	}

	var auths []*PolicyAuthorization
	for _, auth := range context.usedAuthorizations {
		if len(auth.NonceTPM) > 0 {
			// skip authorizations that contain the session nonce
			continue
		}
		auths = append(auths, auth)
	}

	return tickets, auths, nil
}
