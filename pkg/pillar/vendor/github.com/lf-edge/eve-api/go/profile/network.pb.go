// Copyright(c) 2025 Zededa, Inc.
// SPDX-License-Identifier: Apache-2.0

// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.31.0
// 	protoc        v4.23.4
// source: profile/network.proto

package profile

import (
	evecommon "github.com/lf-edge/eve-api/go/evecommon"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
	reflect "reflect"
	sync "sync"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// ConfigSource specifies where the network configuration originated.
type ConfigSource int32

const (
	// The origin of the configuration is unknown.
	ConfigSource_CONFIG_SOURCE_UNSPECIFIED ConfigSource = 0
	// Received device configuration directly from the controller over HTTPS.
	ConfigSource_CONFIG_SOURCE_CONTROLLER ConfigSource = 1
	// Exported device config from the controller with the controller's signature,
	// and installed via the Single-Use EVE installer as the device's initial configuration.
	ConfigSource_CONFIG_SOURCE_BOOTSTRAP ConfigSource = 2
	// Manually provided network-only config in JSON format and embedded into the EVE installer.
	ConfigSource_CONFIG_SOURCE_OVERRIDE ConfigSource = 3
	// Exported device config from the controller with the controller's signature,
	// imported into the Local Operator Console (LOC), and fetched by the device over HTTPS.
	ConfigSource_CONFIG_SOURCE_LOC ConfigSource = 4
	// Created using a Local Profile Server (LPS) application and fetched
	// by the device using the LPS API (currently HTTP-only).
	ConfigSource_CONFIG_SOURCE_LPS ConfigSource = 5
)

// Enum value maps for ConfigSource.
var (
	ConfigSource_name = map[int32]string{
		0: "CONFIG_SOURCE_UNSPECIFIED",
		1: "CONFIG_SOURCE_CONTROLLER",
		2: "CONFIG_SOURCE_BOOTSTRAP",
		3: "CONFIG_SOURCE_OVERRIDE",
		4: "CONFIG_SOURCE_LOC",
		5: "CONFIG_SOURCE_LPS",
	}
	ConfigSource_value = map[string]int32{
		"CONFIG_SOURCE_UNSPECIFIED": 0,
		"CONFIG_SOURCE_CONTROLLER":  1,
		"CONFIG_SOURCE_BOOTSTRAP":   2,
		"CONFIG_SOURCE_OVERRIDE":    3,
		"CONFIG_SOURCE_LOC":         4,
		"CONFIG_SOURCE_LPS":         5,
	}
)

func (x ConfigSource) Enum() *ConfigSource {
	p := new(ConfigSource)
	*p = x
	return p
}

func (x ConfigSource) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (ConfigSource) Descriptor() protoreflect.EnumDescriptor {
	return file_profile_network_proto_enumTypes[0].Descriptor()
}

func (ConfigSource) Type() protoreflect.EnumType {
	return &file_profile_network_proto_enumTypes[0]
}

func (x ConfigSource) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use ConfigSource.Descriptor instead.
func (ConfigSource) EnumDescriptor() ([]byte, []int) {
	return file_profile_network_proto_rawDescGZIP(), []int{0}
}

// Specifies the IP version(s) enabled on a network port.
type IPVersion int32

const (
	// IP version is not specified.
	// But default, port operates in dual-stack mode.
	IPVersion_IP_VERSION_UNSPECIFIED IPVersion = 0
	// Port operates in dual-stack mode, supporting both IPv4 and IPv6 simultaneously.
	IPVersion_IP_VERSION_DUAL_STACK IPVersion = 1
	// Port operates with IPv4 only.
	IPVersion_IP_VERSION_IPV4_ONLY IPVersion = 2
	// Port operates with IPv6 only.
	IPVersion_IP_VERSION_IPV6_ONLY IPVersion = 3
)

// Enum value maps for IPVersion.
var (
	IPVersion_name = map[int32]string{
		0: "IP_VERSION_UNSPECIFIED",
		1: "IP_VERSION_DUAL_STACK",
		2: "IP_VERSION_IPV4_ONLY",
		3: "IP_VERSION_IPV6_ONLY",
	}
	IPVersion_value = map[string]int32{
		"IP_VERSION_UNSPECIFIED": 0,
		"IP_VERSION_DUAL_STACK":  1,
		"IP_VERSION_IPV4_ONLY":   2,
		"IP_VERSION_IPV6_ONLY":   3,
	}
)

func (x IPVersion) Enum() *IPVersion {
	p := new(IPVersion)
	*p = x
	return p
}

func (x IPVersion) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (IPVersion) Descriptor() protoreflect.EnumDescriptor {
	return file_profile_network_proto_enumTypes[1].Descriptor()
}

func (IPVersion) Type() protoreflect.EnumType {
	return &file_profile_network_proto_enumTypes[1]
}

func (x IPVersion) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use IPVersion.Descriptor instead.
func (IPVersion) EnumDescriptor() ([]byte, []int) {
	return file_profile_network_proto_rawDescGZIP(), []int{1}
}

// Enum representing the type of wireless device associated with the network port.
type WirelessType int32

const (
	// Indicates that the device is not a wireless device.
	WirelessType_WIRELESS_TYPE_UNSPECIFIED WirelessType = 0
	// Indicates that the device is a cellular modem.
	WirelessType_WIRELESS_TYPE_CELLULAR WirelessType = 1
	// Indicates that the device is a WiFi adapter.
	WirelessType_WIRELESS_TYPE_WIFI WirelessType = 2
)

// Enum value maps for WirelessType.
var (
	WirelessType_name = map[int32]string{
		0: "WIRELESS_TYPE_UNSPECIFIED",
		1: "WIRELESS_TYPE_CELLULAR",
		2: "WIRELESS_TYPE_WIFI",
	}
	WirelessType_value = map[string]int32{
		"WIRELESS_TYPE_UNSPECIFIED": 0,
		"WIRELESS_TYPE_CELLULAR":    1,
		"WIRELESS_TYPE_WIFI":        2,
	}
)

func (x WirelessType) Enum() *WirelessType {
	p := new(WirelessType)
	*p = x
	return p
}

func (x WirelessType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (WirelessType) Descriptor() protoreflect.EnumDescriptor {
	return file_profile_network_proto_enumTypes[2].Descriptor()
}

func (WirelessType) Type() protoreflect.EnumType {
	return &file_profile_network_proto_enumTypes[2]
}

func (x WirelessType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use WirelessType.Descriptor instead.
func (WirelessType) EnumDescriptor() ([]byte, []int) {
	return file_profile_network_proto_rawDescGZIP(), []int{2}
}

// NetworkInfo is sent by EVE in a POST request to the `api/v1/network` endpoint.
// It publishes multiple configurations for each network port, including:
//   - The latest configuration received from the controller.
//   - The fallback configuration used when controller connectivity is lost
//     or the latest configuration is invalid.
//   - Any locally modified configuration (e.g., from LPS) that overrides
//     controller or fallback settings.
//
// For each port, the `NetworkPortConfig.config_applied` flag indicates which
// of these configurations is currently active on the device.
type NetworkInfo struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// The most recent network configuration received from the controller.
	LatestConfig *NetworkConfig `protobuf:"bytes,1,opt,name=latest_config,json=latestConfig,proto3" json:"latest_config,omitempty"`
	// Current status of controller connectivity and the state of fallback configuration.
	ConfigTesting *NetworkConfigTestingStatus `protobuf:"bytes,2,opt,name=config_testing,json=configTesting,proto3" json:"config_testing,omitempty"`
	// True if EVE is currently using a fallback configuration due to controller
	// connectivity loss.
	IsUsingFallbackConfig bool `protobuf:"varint,3,opt,name=is_using_fallback_config,json=isUsingFallbackConfig,proto3" json:"is_using_fallback_config,omitempty"`
	// The fallback network configuration currently in use.
	// Empty if not using fallback configuration.
	FallbackConfig *NetworkConfig `protobuf:"bytes,4,opt,name=fallback_config,json=fallbackConfig,proto3" json:"fallback_config,omitempty"`
	// Contains only the ports with locally modified configurations and/or associated
	// error messages. Errors may result from LPS-provided configuration being invalid
	// or from changes not being permitted for the given port.
	// This represents the subset of the configuration that differs from
	// the controller-provided configuration due to changes requested by LPS.
	// Ports not listed here are using either the latest controller config
	// or the fallback config, as indicated by `config_testing`.
	LocalChanges *NetworkConfig `protobuf:"bytes,5,opt,name=local_changes,json=localChanges,proto3" json:"local_changes,omitempty"`
}

func (x *NetworkInfo) Reset() {
	*x = NetworkInfo{}
	if protoimpl.UnsafeEnabled {
		mi := &file_profile_network_proto_msgTypes[0]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *NetworkInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NetworkInfo) ProtoMessage() {}

func (x *NetworkInfo) ProtoReflect() protoreflect.Message {
	mi := &file_profile_network_proto_msgTypes[0]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use NetworkInfo.ProtoReflect.Descriptor instead.
func (*NetworkInfo) Descriptor() ([]byte, []int) {
	return file_profile_network_proto_rawDescGZIP(), []int{0}
}

func (x *NetworkInfo) GetLatestConfig() *NetworkConfig {
	if x != nil {
		return x.LatestConfig
	}
	return nil
}

func (x *NetworkInfo) GetConfigTesting() *NetworkConfigTestingStatus {
	if x != nil {
		return x.ConfigTesting
	}
	return nil
}

func (x *NetworkInfo) GetIsUsingFallbackConfig() bool {
	if x != nil {
		return x.IsUsingFallbackConfig
	}
	return false
}

func (x *NetworkInfo) GetFallbackConfig() *NetworkConfig {
	if x != nil {
		return x.FallbackConfig
	}
	return nil
}

func (x *NetworkInfo) GetLocalChanges() *NetworkConfig {
	if x != nil {
		return x.LocalChanges
	}
	return nil
}

// Reports the current status of controller connectivity testing.
type NetworkConfigTestingStatus struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// True if the device currently has connectivity to the controller.
	ControllerReachable bool `protobuf:"varint,1,opt,name=controller_reachable,json=controllerReachable,proto3" json:"controller_reachable,omitempty"`
	// Describes the last connectivity failure; empty if connectivity is fine.
	ConnectivityError string `protobuf:"bytes,2,opt,name=connectivity_error,json=connectivityError,proto3" json:"connectivity_error,omitempty"`
	// Timestamp of the most recent controller connectivity test.
	LastTestTime *timestamppb.Timestamp `protobuf:"bytes,3,opt,name=last_test_time,json=lastTestTime,proto3" json:"last_test_time,omitempty"`
}

func (x *NetworkConfigTestingStatus) Reset() {
	*x = NetworkConfigTestingStatus{}
	if protoimpl.UnsafeEnabled {
		mi := &file_profile_network_proto_msgTypes[1]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *NetworkConfigTestingStatus) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NetworkConfigTestingStatus) ProtoMessage() {}

func (x *NetworkConfigTestingStatus) ProtoReflect() protoreflect.Message {
	mi := &file_profile_network_proto_msgTypes[1]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use NetworkConfigTestingStatus.ProtoReflect.Descriptor instead.
func (*NetworkConfigTestingStatus) Descriptor() ([]byte, []int) {
	return file_profile_network_proto_rawDescGZIP(), []int{1}
}

func (x *NetworkConfigTestingStatus) GetControllerReachable() bool {
	if x != nil {
		return x.ControllerReachable
	}
	return false
}

func (x *NetworkConfigTestingStatus) GetConnectivityError() string {
	if x != nil {
		return x.ConnectivityError
	}
	return ""
}

func (x *NetworkConfigTestingStatus) GetLastTestTime() *timestamppb.Timestamp {
	if x != nil {
		return x.LastTestTime
	}
	return nil
}

// NetworkConfigChange is optionally returned by the local profile server in response to a POST
// request to the `api/v1/network` endpoint.
// If no changes are required, LPS may return HTTP code 204 (no content).
type NetworkConfigChange struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Security token. EVE verifies that `server_token` matches the profile server
	// token provisioned via the controller.
	ServerToken string `protobuf:"bytes,1,opt,name=server_token,json=serverToken,proto3" json:"server_token,omitempty"`
	// New or updated network configuration for one or more network ports.
	// Ports not listed here will keep their current configuration unchanged.
	ConfigChanges *NetworkConfig `protobuf:"bytes,2,opt,name=config_changes,json=configChanges,proto3" json:"config_changes,omitempty"`
}

func (x *NetworkConfigChange) Reset() {
	*x = NetworkConfigChange{}
	if protoimpl.UnsafeEnabled {
		mi := &file_profile_network_proto_msgTypes[2]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *NetworkConfigChange) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NetworkConfigChange) ProtoMessage() {}

func (x *NetworkConfigChange) ProtoReflect() protoreflect.Message {
	mi := &file_profile_network_proto_msgTypes[2]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use NetworkConfigChange.ProtoReflect.Descriptor instead.
func (*NetworkConfigChange) Descriptor() ([]byte, []int) {
	return file_profile_network_proto_rawDescGZIP(), []int{2}
}

func (x *NetworkConfigChange) GetServerToken() string {
	if x != nil {
		return x.ServerToken
	}
	return ""
}

func (x *NetworkConfigChange) GetConfigChanges() *NetworkConfig {
	if x != nil {
		return x.ConfigChanges
	}
	return nil
}

// NetworkConfig represents a collection of network port configurations.
// When included in a NetworkConfigChange message, it should contain only
// the ports that require updated configurations.
type NetworkConfig struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// List of network port configurations.
	Ports []*NetworkPortConfig `protobuf:"bytes,1,rep,name=ports,proto3" json:"ports,omitempty"`
	// Identifies the origin of this configuration.
	ConfigSource ConfigSource `protobuf:"varint,2,opt,name=config_source,json=configSource,proto3,enum=org.lfedge.eve.profile.ConfigSource" json:"config_source,omitempty"`
	// Timestamp indicating when this configuration was applied.
	// When included in a NetworkConfigChange message, this field should be left empty.
	// EVE will automatically populate it with the time the configuration was received
	// from LPS.
	SubmittedAt *timestamppb.Timestamp `protobuf:"bytes,3,opt,name=submitted_at,json=submittedAt,proto3" json:"submitted_at,omitempty"`
	// Error message describing why the last submitted configuration was
	// not fully/partially applied.
	// This may include validation errors for configurations received from either
	// the controller or LPS, or permission-related errors for configuration changes
	// requested by LPS. Empty if the last submitted configuration was applied successfully.
	// For port-specific validation/permission errors, see `NetworkPortConfig.error_message`
	ErrorMessage string `protobuf:"bytes,4,opt,name=error_message,json=errorMessage,proto3" json:"error_message,omitempty"`
}

func (x *NetworkConfig) Reset() {
	*x = NetworkConfig{}
	if protoimpl.UnsafeEnabled {
		mi := &file_profile_network_proto_msgTypes[3]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *NetworkConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NetworkConfig) ProtoMessage() {}

func (x *NetworkConfig) ProtoReflect() protoreflect.Message {
	mi := &file_profile_network_proto_msgTypes[3]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use NetworkConfig.ProtoReflect.Descriptor instead.
func (*NetworkConfig) Descriptor() ([]byte, []int) {
	return file_profile_network_proto_rawDescGZIP(), []int{3}
}

func (x *NetworkConfig) GetPorts() []*NetworkPortConfig {
	if x != nil {
		return x.Ports
	}
	return nil
}

func (x *NetworkConfig) GetConfigSource() ConfigSource {
	if x != nil {
		return x.ConfigSource
	}
	return ConfigSource_CONFIG_SOURCE_UNSPECIFIED
}

func (x *NetworkConfig) GetSubmittedAt() *timestamppb.Timestamp {
	if x != nil {
		return x.SubmittedAt
	}
	return nil
}

func (x *NetworkConfig) GetErrorMessage() string {
	if x != nil {
		return x.ErrorMessage
	}
	return ""
}

// Specifies system and hardware identifiers for a network port.
// These fields are included in NetworkInfo to help the user identify the port,
// but may be omitted in NetworkConfigChange. None of these identifiers
// (including the interface name) can be changed.
// For identification in NetworkConfigChange, use the port's logical label instead.
type NetworkPortAddresses struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// The interface name assigned by the Linux kernel.
	InterfaceName string `protobuf:"bytes,1,opt,name=interface_name,json=interfaceName,proto3" json:"interface_name,omitempty"`
	// PCI address of the network adapter in the long format.
	// For example: `0000:00:15.0`
	PciAddress string `protobuf:"bytes,2,opt,name=pci_address,json=pciAddress,proto3" json:"pci_address,omitempty"`
	// USB address of the network adapter in the format `<BUS>:[<PORT>]`, with nested ports
	// separated by dots. For example: `1:2.3`
	// Empty if the network adapter is not a USB device.
	UsbAdapter string `protobuf:"bytes,3,opt,name=usb_adapter,json=usbAdapter,proto3" json:"usb_adapter,omitempty"`
}

func (x *NetworkPortAddresses) Reset() {
	*x = NetworkPortAddresses{}
	if protoimpl.UnsafeEnabled {
		mi := &file_profile_network_proto_msgTypes[4]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *NetworkPortAddresses) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NetworkPortAddresses) ProtoMessage() {}

func (x *NetworkPortAddresses) ProtoReflect() protoreflect.Message {
	mi := &file_profile_network_proto_msgTypes[4]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use NetworkPortAddresses.ProtoReflect.Descriptor instead.
func (*NetworkPortAddresses) Descriptor() ([]byte, []int) {
	return file_profile_network_proto_rawDescGZIP(), []int{4}
}

func (x *NetworkPortAddresses) GetInterfaceName() string {
	if x != nil {
		return x.InterfaceName
	}
	return ""
}

func (x *NetworkPortAddresses) GetPciAddress() string {
	if x != nil {
		return x.PciAddress
	}
	return ""
}

func (x *NetworkPortAddresses) GetUsbAdapter() string {
	if x != nil {
		return x.UsbAdapter
	}
	return ""
}

// NetworkPortConfig defines the configuration settings for a network port on a device.
// It includes identification fields, IP addressing details, routing information,
// DNS and NTP servers, MTU settings, and optional proxy and wireless adapter configurations.
//
// This message supports both static and DHCP-based IP configurations.
// When DHCP is enabled (`use_dhcp` = true), static IP fields can still be specified.
// By default, static configurations are merged with DHCP-provided settings,
// but the user can control, for each IP-related field, whether static config
// should override DHCP values or be merged alongside them.
//
// For cellular modems, IP settings are always provided by the cellular network,
// so user-specified IP configurations are ignored during cellular modem updates.
type NetworkPortConfig struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Port logical name used in the device model.
	LogicalName string `protobuf:"bytes,1,opt,name=logical_name,json=logicalName,proto3" json:"logical_name,omitempty"`
	// System and hardware identifiers for the network port, used for informational purposes only.
	PortAddresses *NetworkPortAddresses `protobuf:"bytes,2,opt,name=port_addresses,json=portAddresses,proto3" json:"port_addresses,omitempty"`
	// Indicates whether this configuration is currently applied to the port.
	// If false, the port is using a different configuration (latest controller config,
	// local change, or fallback) instead of this one.
	ConfigApplied bool `protobuf:"varint,3,opt,name=config_applied,json=configApplied,proto3" json:"config_applied,omitempty"`
	// IP version(s) enabled for the port.
	IpVersion IPVersion `protobuf:"varint,4,opt,name=ip_version,json=ipVersion,proto3,enum=org.lfedge.eve.profile.IPVersion" json:"ip_version,omitempty"`
	// Enables DHCP for IP configuration.
	// When enabled, static IP configurations can still be provided.
	// By default, static settings are merged with DHCP-provided configuration,
	// but merging behavior can be controlled per IP-related field.
	UseDhcp bool `protobuf:"varint,5,opt,name=use_dhcp,json=useDhcp,proto3" json:"use_dhcp,omitempty"`
	// Specifies which DHCP options should be ignored when merging static and DHCP
	// configurations.
	DhcpOptionsIgnore *evecommon.DhcpOptionsIgnore `protobuf:"bytes,6,opt,name=dhcp_options_ignore,json=dhcpOptionsIgnore,proto3" json:"dhcp_options_ignore,omitempty"`
	// Static IP addresses, in CIDR format (e.g., "192.168.1.10/24").
	IpAddresses []string `protobuf:"bytes,7,rep,name=ip_addresses,json=ipAddresses,proto3" json:"ip_addresses,omitempty"`
	// Statically configured gateway IP addresses.
	// Use the `without_default_route` option to specify whether these gateways
	// should NOT be used as default routes.
	// When `without_default_route` is true, no default route will be added
	// for this adapter, regardless of the gateway list or DHCP settings.
	Gateways []string `protobuf:"bytes,8,rep,name=gateways,proto3" json:"gateways,omitempty"`
	// When set to true, the network adapter will be configured without any default route.
	// This overrides gateway settings and applies even if DHCP is enabled (`use_dhcp = true`).
	WithoutDefaultRoute bool `protobuf:"varint,9,opt,name=without_default_route,json=withoutDefaultRoute,proto3" json:"without_default_route,omitempty"`
	// Statically configured DNS server IP addresses.
	DnsServers []string `protobuf:"bytes,10,rep,name=dns_servers,json=dnsServers,proto3" json:"dns_servers,omitempty"`
	// Statically configured local DNS domain suffix.
	DnsDomain string `protobuf:"bytes,11,opt,name=dns_domain,json=dnsDomain,proto3" json:"dns_domain,omitempty"`
	// Statically configured NTP server addresses (IP or hostname).
	NtpServers []string `protobuf:"bytes,12,rep,name=ntp_servers,json=ntpServers,proto3" json:"ntp_servers,omitempty"`
	// MTU (Maximum Transmission Unit) in bytes.
	// The max allowed value is 65535 (protobuf does not define uint16).
	// If not defined (zero value), EVE will set the default MTU size, which depends
	// on the network adapter type. Ethernet and WiFi adapters default to 1500 bytes,
	// while cellular modems typically receive their MTU value from the network provider
	// (which EVE will use unless user overrides the MTU value).
	Mtu uint32 `protobuf:"varint,13,opt,name=mtu,proto3" json:"mtu,omitempty"`
	// Proxy configuration.
	ProxyConfig *evecommon.ProxyConfig `protobuf:"bytes,14,opt,name=proxy_config,json=proxyConfig,proto3" json:"proxy_config,omitempty"`
	// Specifies the type of wireless device.
	// Should correspond to which oneof field is set in `wireless_config`.
	WirelessDeviceType WirelessType `protobuf:"varint,15,opt,name=wireless_device_type,json=wirelessDeviceType,proto3,enum=org.lfedge.eve.profile.WirelessType" json:"wireless_device_type,omitempty"`
	// Configuration for wireless adapter (WiFi or cellular modem).
	// When cellular modem configuration is being changed in NetworkConfigChange,
	// IP fields like addresses, DNS, gateways, etc. should not be specified because
	// they are always received from the cellular network (EVE will ignore
	// user-specified IP config).
	//
	// Types that are assignable to WirelessConfig:
	//
	//	*NetworkPortConfig_CellularConfig
	//	*NetworkPortConfig_WifiConfig
	WirelessConfig isNetworkPortConfig_WirelessConfig `protobuf_oneof:"wireless_config"`
	// Error message associated with this specific port configuration.
	// Indicates whether the configuration is invalid or if a change requested
	// by the Local Profile Server was not permitted.
	// This field is empty if the last applied configuration for this port
	// was accepted successfully.
	// If the configuration is invalid or not permitted, EVE may reject it,
	// although the exact behavior depends on the configuration source.
	// Use the `config_applied` field to check whether this configuration
	// was at least partially applied and is currently active despite any errors.
	ErrorMessage string `protobuf:"bytes,20,opt,name=error_message,json=errorMessage,proto3" json:"error_message,omitempty"`
}

func (x *NetworkPortConfig) Reset() {
	*x = NetworkPortConfig{}
	if protoimpl.UnsafeEnabled {
		mi := &file_profile_network_proto_msgTypes[5]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *NetworkPortConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NetworkPortConfig) ProtoMessage() {}

func (x *NetworkPortConfig) ProtoReflect() protoreflect.Message {
	mi := &file_profile_network_proto_msgTypes[5]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use NetworkPortConfig.ProtoReflect.Descriptor instead.
func (*NetworkPortConfig) Descriptor() ([]byte, []int) {
	return file_profile_network_proto_rawDescGZIP(), []int{5}
}

func (x *NetworkPortConfig) GetLogicalName() string {
	if x != nil {
		return x.LogicalName
	}
	return ""
}

func (x *NetworkPortConfig) GetPortAddresses() *NetworkPortAddresses {
	if x != nil {
		return x.PortAddresses
	}
	return nil
}

func (x *NetworkPortConfig) GetConfigApplied() bool {
	if x != nil {
		return x.ConfigApplied
	}
	return false
}

func (x *NetworkPortConfig) GetIpVersion() IPVersion {
	if x != nil {
		return x.IpVersion
	}
	return IPVersion_IP_VERSION_UNSPECIFIED
}

func (x *NetworkPortConfig) GetUseDhcp() bool {
	if x != nil {
		return x.UseDhcp
	}
	return false
}

func (x *NetworkPortConfig) GetDhcpOptionsIgnore() *evecommon.DhcpOptionsIgnore {
	if x != nil {
		return x.DhcpOptionsIgnore
	}
	return nil
}

func (x *NetworkPortConfig) GetIpAddresses() []string {
	if x != nil {
		return x.IpAddresses
	}
	return nil
}

func (x *NetworkPortConfig) GetGateways() []string {
	if x != nil {
		return x.Gateways
	}
	return nil
}

func (x *NetworkPortConfig) GetWithoutDefaultRoute() bool {
	if x != nil {
		return x.WithoutDefaultRoute
	}
	return false
}

func (x *NetworkPortConfig) GetDnsServers() []string {
	if x != nil {
		return x.DnsServers
	}
	return nil
}

func (x *NetworkPortConfig) GetDnsDomain() string {
	if x != nil {
		return x.DnsDomain
	}
	return ""
}

func (x *NetworkPortConfig) GetNtpServers() []string {
	if x != nil {
		return x.NtpServers
	}
	return nil
}

func (x *NetworkPortConfig) GetMtu() uint32 {
	if x != nil {
		return x.Mtu
	}
	return 0
}

func (x *NetworkPortConfig) GetProxyConfig() *evecommon.ProxyConfig {
	if x != nil {
		return x.ProxyConfig
	}
	return nil
}

func (x *NetworkPortConfig) GetWirelessDeviceType() WirelessType {
	if x != nil {
		return x.WirelessDeviceType
	}
	return WirelessType_WIRELESS_TYPE_UNSPECIFIED
}

func (m *NetworkPortConfig) GetWirelessConfig() isNetworkPortConfig_WirelessConfig {
	if m != nil {
		return m.WirelessConfig
	}
	return nil
}

func (x *NetworkPortConfig) GetCellularConfig() *CellularConfig {
	if x, ok := x.GetWirelessConfig().(*NetworkPortConfig_CellularConfig); ok {
		return x.CellularConfig
	}
	return nil
}

func (x *NetworkPortConfig) GetWifiConfig() *WifiConfig {
	if x, ok := x.GetWirelessConfig().(*NetworkPortConfig_WifiConfig); ok {
		return x.WifiConfig
	}
	return nil
}

func (x *NetworkPortConfig) GetErrorMessage() string {
	if x != nil {
		return x.ErrorMessage
	}
	return ""
}

type isNetworkPortConfig_WirelessConfig interface {
	isNetworkPortConfig_WirelessConfig()
}

type NetworkPortConfig_CellularConfig struct {
	// Configuration details specific to a cellular modem.
	CellularConfig *CellularConfig `protobuf:"bytes,16,opt,name=cellular_config,json=cellularConfig,proto3,oneof"`
}

type NetworkPortConfig_WifiConfig struct {
	// Configuration details specific to a WiFi adapter.
	WifiConfig *WifiConfig `protobuf:"bytes,17,opt,name=wifi_config,json=wifiConfig,proto3,oneof"`
}

func (*NetworkPortConfig_CellularConfig) isNetworkPortConfig_WirelessConfig() {}

func (*NetworkPortConfig_WifiConfig) isNetworkPortConfig_WirelessConfig() {}

// Configuration details specific to a cellular modem.
type CellularConfig struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Access Point Name (APN) for the default bearer. Defaults to "internet".
	Apn string `protobuf:"bytes,1,opt,name=apn,proto3" json:"apn,omitempty"`
	// APN used for the attach (initial) bearer.
	// Optional. If omitted, EVE will skip submitting attach bearer configuration
	// to the modem, allowing the modem to fall back to its internal/default profiles.
	AttachApn string `protobuf:"bytes,2,opt,name=attach_apn,json=attachApn,proto3" json:"attach_apn,omitempty"`
	// IP address type for the default bearer.
	IpType evecommon.CellularIPType `protobuf:"varint,3,opt,name=ip_type,json=ipType,proto3,enum=org.lfedge.eve.common.CellularIPType" json:"ip_type,omitempty"`
	// IP address type for the attach bearer. Ignored if attach_apn is not set.
	AttachIpType evecommon.CellularIPType `protobuf:"varint,4,opt,name=attach_ip_type,json=attachIpType,proto3,enum=org.lfedge.eve.common.CellularIPType" json:"attach_ip_type,omitempty"`
	// SIM card slot to activate (single-standby only).
	// 0 = unspecified (keep the current);
	// 1 = activate the first SIM slot;
	// 2 = activate the second SIM slot;
	// etc.
	ActivateSimSlot uint32 `protobuf:"varint,5,opt,name=activate_sim_slot,json=activateSimSlot,proto3" json:"activate_sim_slot,omitempty"`
	// If true, roaming is disabled.
	DisableRoaming bool `protobuf:"varint,6,opt,name=disable_roaming,json=disableRoaming,proto3" json:"disable_roaming,omitempty"`
	// Authentication settings for the default bearer.
	DefaultBearerAuth *CellularNetworkAuth `protobuf:"bytes,7,opt,name=default_bearer_auth,json=defaultBearerAuth,proto3" json:"default_bearer_auth,omitempty"`
	// Authentication settings for the attach bearer.
	AttachBearerAuth *CellularNetworkAuth `protobuf:"bytes,8,opt,name=attach_bearer_auth,json=attachBearerAuth,proto3" json:"attach_bearer_auth,omitempty"`
}

func (x *CellularConfig) Reset() {
	*x = CellularConfig{}
	if protoimpl.UnsafeEnabled {
		mi := &file_profile_network_proto_msgTypes[6]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *CellularConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CellularConfig) ProtoMessage() {}

func (x *CellularConfig) ProtoReflect() protoreflect.Message {
	mi := &file_profile_network_proto_msgTypes[6]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CellularConfig.ProtoReflect.Descriptor instead.
func (*CellularConfig) Descriptor() ([]byte, []int) {
	return file_profile_network_proto_rawDescGZIP(), []int{6}
}

func (x *CellularConfig) GetApn() string {
	if x != nil {
		return x.Apn
	}
	return ""
}

func (x *CellularConfig) GetAttachApn() string {
	if x != nil {
		return x.AttachApn
	}
	return ""
}

func (x *CellularConfig) GetIpType() evecommon.CellularIPType {
	if x != nil {
		return x.IpType
	}
	return evecommon.CellularIPType(0)
}

func (x *CellularConfig) GetAttachIpType() evecommon.CellularIPType {
	if x != nil {
		return x.AttachIpType
	}
	return evecommon.CellularIPType(0)
}

func (x *CellularConfig) GetActivateSimSlot() uint32 {
	if x != nil {
		return x.ActivateSimSlot
	}
	return 0
}

func (x *CellularConfig) GetDisableRoaming() bool {
	if x != nil {
		return x.DisableRoaming
	}
	return false
}

func (x *CellularConfig) GetDefaultBearerAuth() *CellularNetworkAuth {
	if x != nil {
		return x.DefaultBearerAuth
	}
	return nil
}

func (x *CellularConfig) GetAttachBearerAuth() *CellularNetworkAuth {
	if x != nil {
		return x.AttachBearerAuth
	}
	return nil
}

// CellularNetworkAuth defines the authentication credentials and protocol
// used to connect to a cellular network. It includes sensitive information
// such as username and password, which are not published to LPS in status reports
// but can be configured by LPS via network configuration updates.
type CellularNetworkAuth struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Authentication protocol used for cellular network access.
	AuthProtocol evecommon.CellularAuthProtocol `protobuf:"varint,1,opt,name=auth_protocol,json=authProtocol,proto3,enum=org.lfedge.eve.common.CellularAuthProtocol" json:"auth_protocol,omitempty"`
	// Username is not published in NetworkInfo but may be set in NetworkConfigChange.
	Username string `protobuf:"bytes,2,opt,name=username,proto3" json:"username,omitempty"`
	// Password is not published in NetworkInfo but may be set in NetworkConfigChange.
	Password string `protobuf:"bytes,3,opt,name=password,proto3" json:"password,omitempty"`
}

func (x *CellularNetworkAuth) Reset() {
	*x = CellularNetworkAuth{}
	if protoimpl.UnsafeEnabled {
		mi := &file_profile_network_proto_msgTypes[7]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *CellularNetworkAuth) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CellularNetworkAuth) ProtoMessage() {}

func (x *CellularNetworkAuth) ProtoReflect() protoreflect.Message {
	mi := &file_profile_network_proto_msgTypes[7]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CellularNetworkAuth.ProtoReflect.Descriptor instead.
func (*CellularNetworkAuth) Descriptor() ([]byte, []int) {
	return file_profile_network_proto_rawDescGZIP(), []int{7}
}

func (x *CellularNetworkAuth) GetAuthProtocol() evecommon.CellularAuthProtocol {
	if x != nil {
		return x.AuthProtocol
	}
	return evecommon.CellularAuthProtocol(0)
}

func (x *CellularNetworkAuth) GetUsername() string {
	if x != nil {
		return x.Username
	}
	return ""
}

func (x *CellularNetworkAuth) GetPassword() string {
	if x != nil {
		return x.Password
	}
	return ""
}

// Configuration details specific to a WiFi adapter.
type WifiConfig struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// SSID (network name) of the WiFi network.
	Ssid string `protobuf:"bytes,1,opt,name=ssid,proto3" json:"ssid,omitempty"`
	// Key management scheme (e.g., WPA-PSK, WPA-EAP).
	KeyScheme evecommon.WiFiKeyScheme `protobuf:"varint,2,opt,name=key_scheme,json=keyScheme,proto3,enum=org.lfedge.eve.common.WiFiKeyScheme" json:"key_scheme,omitempty"`
	// Identity/username for WPA2 Enterprise networks.
	// Not included in NetworkInfo, but can be updated via NetworkConfigChange.
	Identity string `protobuf:"bytes,3,opt,name=identity,proto3" json:"identity,omitempty"`
	// WiFi password or pre-shared key (PSK).
	// This value should be the hashed PSK generated by the `wpa_passphrase` tool.
	// For security, it is excluded from NetworkInfo but can be updated through
	// NetworkConfigChange.
	Password string `protobuf:"bytes,4,opt,name=password,proto3" json:"password,omitempty"`
}

func (x *WifiConfig) Reset() {
	*x = WifiConfig{}
	if protoimpl.UnsafeEnabled {
		mi := &file_profile_network_proto_msgTypes[8]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *WifiConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*WifiConfig) ProtoMessage() {}

func (x *WifiConfig) ProtoReflect() protoreflect.Message {
	mi := &file_profile_network_proto_msgTypes[8]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use WifiConfig.ProtoReflect.Descriptor instead.
func (*WifiConfig) Descriptor() ([]byte, []int) {
	return file_profile_network_proto_rawDescGZIP(), []int{8}
}

func (x *WifiConfig) GetSsid() string {
	if x != nil {
		return x.Ssid
	}
	return ""
}

func (x *WifiConfig) GetKeyScheme() evecommon.WiFiKeyScheme {
	if x != nil {
		return x.KeyScheme
	}
	return evecommon.WiFiKeyScheme(0)
}

func (x *WifiConfig) GetIdentity() string {
	if x != nil {
		return x.Identity
	}
	return ""
}

func (x *WifiConfig) GetPassword() string {
	if x != nil {
		return x.Password
	}
	return ""
}

var File_profile_network_proto protoreflect.FileDescriptor

var file_profile_network_proto_rawDesc = []byte{
	0x0a, 0x15, 0x70, 0x72, 0x6f, 0x66, 0x69, 0x6c, 0x65, 0x2f, 0x6e, 0x65, 0x74, 0x77, 0x6f, 0x72,
	0x6b, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x16, 0x6f, 0x72, 0x67, 0x2e, 0x6c, 0x66, 0x65,
	0x64, 0x67, 0x65, 0x2e, 0x65, 0x76, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x66, 0x69, 0x6c, 0x65, 0x1a,
	0x1f, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2f, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66,
	0x2f, 0x74, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f,
	0x1a, 0x16, 0x65, 0x76, 0x65, 0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2f, 0x6e, 0x65, 0x74, 0x63,
	0x6d, 0x6e, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x22, 0x89, 0x03, 0x0a, 0x0b, 0x4e, 0x65, 0x74,
	0x77, 0x6f, 0x72, 0x6b, 0x49, 0x6e, 0x66, 0x6f, 0x12, 0x4a, 0x0a, 0x0d, 0x6c, 0x61, 0x74, 0x65,
	0x73, 0x74, 0x5f, 0x63, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32,
	0x25, 0x2e, 0x6f, 0x72, 0x67, 0x2e, 0x6c, 0x66, 0x65, 0x64, 0x67, 0x65, 0x2e, 0x65, 0x76, 0x65,
	0x2e, 0x70, 0x72, 0x6f, 0x66, 0x69, 0x6c, 0x65, 0x2e, 0x4e, 0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b,
	0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x52, 0x0c, 0x6c, 0x61, 0x74, 0x65, 0x73, 0x74, 0x43, 0x6f,
	0x6e, 0x66, 0x69, 0x67, 0x12, 0x59, 0x0a, 0x0e, 0x63, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x5f, 0x74,
	0x65, 0x73, 0x74, 0x69, 0x6e, 0x67, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x32, 0x2e, 0x6f,
	0x72, 0x67, 0x2e, 0x6c, 0x66, 0x65, 0x64, 0x67, 0x65, 0x2e, 0x65, 0x76, 0x65, 0x2e, 0x70, 0x72,
	0x6f, 0x66, 0x69, 0x6c, 0x65, 0x2e, 0x4e, 0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b, 0x43, 0x6f, 0x6e,
	0x66, 0x69, 0x67, 0x54, 0x65, 0x73, 0x74, 0x69, 0x6e, 0x67, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73,
	0x52, 0x0d, 0x63, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x54, 0x65, 0x73, 0x74, 0x69, 0x6e, 0x67, 0x12,
	0x37, 0x0a, 0x18, 0x69, 0x73, 0x5f, 0x75, 0x73, 0x69, 0x6e, 0x67, 0x5f, 0x66, 0x61, 0x6c, 0x6c,
	0x62, 0x61, 0x63, 0x6b, 0x5f, 0x63, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x18, 0x03, 0x20, 0x01, 0x28,
	0x08, 0x52, 0x15, 0x69, 0x73, 0x55, 0x73, 0x69, 0x6e, 0x67, 0x46, 0x61, 0x6c, 0x6c, 0x62, 0x61,
	0x63, 0x6b, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x12, 0x4e, 0x0a, 0x0f, 0x66, 0x61, 0x6c, 0x6c,
	0x62, 0x61, 0x63, 0x6b, 0x5f, 0x63, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x18, 0x04, 0x20, 0x01, 0x28,
	0x0b, 0x32, 0x25, 0x2e, 0x6f, 0x72, 0x67, 0x2e, 0x6c, 0x66, 0x65, 0x64, 0x67, 0x65, 0x2e, 0x65,
	0x76, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x66, 0x69, 0x6c, 0x65, 0x2e, 0x4e, 0x65, 0x74, 0x77, 0x6f,
	0x72, 0x6b, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x52, 0x0e, 0x66, 0x61, 0x6c, 0x6c, 0x62, 0x61,
	0x63, 0x6b, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x12, 0x4a, 0x0a, 0x0d, 0x6c, 0x6f, 0x63, 0x61,
	0x6c, 0x5f, 0x63, 0x68, 0x61, 0x6e, 0x67, 0x65, 0x73, 0x18, 0x05, 0x20, 0x01, 0x28, 0x0b, 0x32,
	0x25, 0x2e, 0x6f, 0x72, 0x67, 0x2e, 0x6c, 0x66, 0x65, 0x64, 0x67, 0x65, 0x2e, 0x65, 0x76, 0x65,
	0x2e, 0x70, 0x72, 0x6f, 0x66, 0x69, 0x6c, 0x65, 0x2e, 0x4e, 0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b,
	0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x52, 0x0c, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x43, 0x68, 0x61,
	0x6e, 0x67, 0x65, 0x73, 0x22, 0xc0, 0x01, 0x0a, 0x1a, 0x4e, 0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b,
	0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x54, 0x65, 0x73, 0x74, 0x69, 0x6e, 0x67, 0x53, 0x74, 0x61,
	0x74, 0x75, 0x73, 0x12, 0x31, 0x0a, 0x14, 0x63, 0x6f, 0x6e, 0x74, 0x72, 0x6f, 0x6c, 0x6c, 0x65,
	0x72, 0x5f, 0x72, 0x65, 0x61, 0x63, 0x68, 0x61, 0x62, 0x6c, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28,
	0x08, 0x52, 0x13, 0x63, 0x6f, 0x6e, 0x74, 0x72, 0x6f, 0x6c, 0x6c, 0x65, 0x72, 0x52, 0x65, 0x61,
	0x63, 0x68, 0x61, 0x62, 0x6c, 0x65, 0x12, 0x2d, 0x0a, 0x12, 0x63, 0x6f, 0x6e, 0x6e, 0x65, 0x63,
	0x74, 0x69, 0x76, 0x69, 0x74, 0x79, 0x5f, 0x65, 0x72, 0x72, 0x6f, 0x72, 0x18, 0x02, 0x20, 0x01,
	0x28, 0x09, 0x52, 0x11, 0x63, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x69, 0x76, 0x69, 0x74, 0x79,
	0x45, 0x72, 0x72, 0x6f, 0x72, 0x12, 0x40, 0x0a, 0x0e, 0x6c, 0x61, 0x73, 0x74, 0x5f, 0x74, 0x65,
	0x73, 0x74, 0x5f, 0x74, 0x69, 0x6d, 0x65, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1a, 0x2e,
	0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e,
	0x54, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x52, 0x0c, 0x6c, 0x61, 0x73, 0x74, 0x54,
	0x65, 0x73, 0x74, 0x54, 0x69, 0x6d, 0x65, 0x22, 0x86, 0x01, 0x0a, 0x13, 0x4e, 0x65, 0x74, 0x77,
	0x6f, 0x72, 0x6b, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x43, 0x68, 0x61, 0x6e, 0x67, 0x65, 0x12,
	0x21, 0x0a, 0x0c, 0x73, 0x65, 0x72, 0x76, 0x65, 0x72, 0x5f, 0x74, 0x6f, 0x6b, 0x65, 0x6e, 0x18,
	0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0b, 0x73, 0x65, 0x72, 0x76, 0x65, 0x72, 0x54, 0x6f, 0x6b,
	0x65, 0x6e, 0x12, 0x4c, 0x0a, 0x0e, 0x63, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x5f, 0x63, 0x68, 0x61,
	0x6e, 0x67, 0x65, 0x73, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x25, 0x2e, 0x6f, 0x72, 0x67,
	0x2e, 0x6c, 0x66, 0x65, 0x64, 0x67, 0x65, 0x2e, 0x65, 0x76, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x66,
	0x69, 0x6c, 0x65, 0x2e, 0x4e, 0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b, 0x43, 0x6f, 0x6e, 0x66, 0x69,
	0x67, 0x52, 0x0d, 0x63, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x43, 0x68, 0x61, 0x6e, 0x67, 0x65, 0x73,
	0x22, 0xff, 0x01, 0x0a, 0x0d, 0x4e, 0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b, 0x43, 0x6f, 0x6e, 0x66,
	0x69, 0x67, 0x12, 0x3f, 0x0a, 0x05, 0x70, 0x6f, 0x72, 0x74, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28,
	0x0b, 0x32, 0x29, 0x2e, 0x6f, 0x72, 0x67, 0x2e, 0x6c, 0x66, 0x65, 0x64, 0x67, 0x65, 0x2e, 0x65,
	0x76, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x66, 0x69, 0x6c, 0x65, 0x2e, 0x4e, 0x65, 0x74, 0x77, 0x6f,
	0x72, 0x6b, 0x50, 0x6f, 0x72, 0x74, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x52, 0x05, 0x70, 0x6f,
	0x72, 0x74, 0x73, 0x12, 0x49, 0x0a, 0x0d, 0x63, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x5f, 0x73, 0x6f,
	0x75, 0x72, 0x63, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x24, 0x2e, 0x6f, 0x72, 0x67,
	0x2e, 0x6c, 0x66, 0x65, 0x64, 0x67, 0x65, 0x2e, 0x65, 0x76, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x66,
	0x69, 0x6c, 0x65, 0x2e, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x53, 0x6f, 0x75, 0x72, 0x63, 0x65,
	0x52, 0x0c, 0x63, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x53, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x12, 0x3d,
	0x0a, 0x0c, 0x73, 0x75, 0x62, 0x6d, 0x69, 0x74, 0x74, 0x65, 0x64, 0x5f, 0x61, 0x74, 0x18, 0x03,
	0x20, 0x01, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72,
	0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x54, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70,
	0x52, 0x0b, 0x73, 0x75, 0x62, 0x6d, 0x69, 0x74, 0x74, 0x65, 0x64, 0x41, 0x74, 0x12, 0x23, 0x0a,
	0x0d, 0x65, 0x72, 0x72, 0x6f, 0x72, 0x5f, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x18, 0x04,
	0x20, 0x01, 0x28, 0x09, 0x52, 0x0c, 0x65, 0x72, 0x72, 0x6f, 0x72, 0x4d, 0x65, 0x73, 0x73, 0x61,
	0x67, 0x65, 0x22, 0x7f, 0x0a, 0x14, 0x4e, 0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b, 0x50, 0x6f, 0x72,
	0x74, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x65, 0x73, 0x12, 0x25, 0x0a, 0x0e, 0x69, 0x6e,
	0x74, 0x65, 0x72, 0x66, 0x61, 0x63, 0x65, 0x5f, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x01, 0x20, 0x01,
	0x28, 0x09, 0x52, 0x0d, 0x69, 0x6e, 0x74, 0x65, 0x72, 0x66, 0x61, 0x63, 0x65, 0x4e, 0x61, 0x6d,
	0x65, 0x12, 0x1f, 0x0a, 0x0b, 0x70, 0x63, 0x69, 0x5f, 0x61, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73,
	0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0a, 0x70, 0x63, 0x69, 0x41, 0x64, 0x64, 0x72, 0x65,
	0x73, 0x73, 0x12, 0x1f, 0x0a, 0x0b, 0x75, 0x73, 0x62, 0x5f, 0x61, 0x64, 0x61, 0x70, 0x74, 0x65,
	0x72, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0a, 0x75, 0x73, 0x62, 0x41, 0x64, 0x61, 0x70,
	0x74, 0x65, 0x72, 0x22, 0xc0, 0x07, 0x0a, 0x11, 0x4e, 0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b, 0x50,
	0x6f, 0x72, 0x74, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x12, 0x21, 0x0a, 0x0c, 0x6c, 0x6f, 0x67,
	0x69, 0x63, 0x61, 0x6c, 0x5f, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52,
	0x0b, 0x6c, 0x6f, 0x67, 0x69, 0x63, 0x61, 0x6c, 0x4e, 0x61, 0x6d, 0x65, 0x12, 0x53, 0x0a, 0x0e,
	0x70, 0x6f, 0x72, 0x74, 0x5f, 0x61, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x65, 0x73, 0x18, 0x02,
	0x20, 0x01, 0x28, 0x0b, 0x32, 0x2c, 0x2e, 0x6f, 0x72, 0x67, 0x2e, 0x6c, 0x66, 0x65, 0x64, 0x67,
	0x65, 0x2e, 0x65, 0x76, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x66, 0x69, 0x6c, 0x65, 0x2e, 0x4e, 0x65,
	0x74, 0x77, 0x6f, 0x72, 0x6b, 0x50, 0x6f, 0x72, 0x74, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73,
	0x65, 0x73, 0x52, 0x0d, 0x70, 0x6f, 0x72, 0x74, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x65,
	0x73, 0x12, 0x25, 0x0a, 0x0e, 0x63, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x5f, 0x61, 0x70, 0x70, 0x6c,
	0x69, 0x65, 0x64, 0x18, 0x03, 0x20, 0x01, 0x28, 0x08, 0x52, 0x0d, 0x63, 0x6f, 0x6e, 0x66, 0x69,
	0x67, 0x41, 0x70, 0x70, 0x6c, 0x69, 0x65, 0x64, 0x12, 0x40, 0x0a, 0x0a, 0x69, 0x70, 0x5f, 0x76,
	0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x21, 0x2e, 0x6f,
	0x72, 0x67, 0x2e, 0x6c, 0x66, 0x65, 0x64, 0x67, 0x65, 0x2e, 0x65, 0x76, 0x65, 0x2e, 0x70, 0x72,
	0x6f, 0x66, 0x69, 0x6c, 0x65, 0x2e, 0x49, 0x50, 0x56, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x52,
	0x09, 0x69, 0x70, 0x56, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x12, 0x19, 0x0a, 0x08, 0x75, 0x73,
	0x65, 0x5f, 0x64, 0x68, 0x63, 0x70, 0x18, 0x05, 0x20, 0x01, 0x28, 0x08, 0x52, 0x07, 0x75, 0x73,
	0x65, 0x44, 0x68, 0x63, 0x70, 0x12, 0x58, 0x0a, 0x13, 0x64, 0x68, 0x63, 0x70, 0x5f, 0x6f, 0x70,
	0x74, 0x69, 0x6f, 0x6e, 0x73, 0x5f, 0x69, 0x67, 0x6e, 0x6f, 0x72, 0x65, 0x18, 0x06, 0x20, 0x01,
	0x28, 0x0b, 0x32, 0x28, 0x2e, 0x6f, 0x72, 0x67, 0x2e, 0x6c, 0x66, 0x65, 0x64, 0x67, 0x65, 0x2e,
	0x65, 0x76, 0x65, 0x2e, 0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2e, 0x44, 0x68, 0x63, 0x70, 0x4f,
	0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x49, 0x67, 0x6e, 0x6f, 0x72, 0x65, 0x52, 0x11, 0x64, 0x68,
	0x63, 0x70, 0x4f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x49, 0x67, 0x6e, 0x6f, 0x72, 0x65, 0x12,
	0x21, 0x0a, 0x0c, 0x69, 0x70, 0x5f, 0x61, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x65, 0x73, 0x18,
	0x07, 0x20, 0x03, 0x28, 0x09, 0x52, 0x0b, 0x69, 0x70, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73,
	0x65, 0x73, 0x12, 0x1a, 0x0a, 0x08, 0x67, 0x61, 0x74, 0x65, 0x77, 0x61, 0x79, 0x73, 0x18, 0x08,
	0x20, 0x03, 0x28, 0x09, 0x52, 0x08, 0x67, 0x61, 0x74, 0x65, 0x77, 0x61, 0x79, 0x73, 0x12, 0x32,
	0x0a, 0x15, 0x77, 0x69, 0x74, 0x68, 0x6f, 0x75, 0x74, 0x5f, 0x64, 0x65, 0x66, 0x61, 0x75, 0x6c,
	0x74, 0x5f, 0x72, 0x6f, 0x75, 0x74, 0x65, 0x18, 0x09, 0x20, 0x01, 0x28, 0x08, 0x52, 0x13, 0x77,
	0x69, 0x74, 0x68, 0x6f, 0x75, 0x74, 0x44, 0x65, 0x66, 0x61, 0x75, 0x6c, 0x74, 0x52, 0x6f, 0x75,
	0x74, 0x65, 0x12, 0x1f, 0x0a, 0x0b, 0x64, 0x6e, 0x73, 0x5f, 0x73, 0x65, 0x72, 0x76, 0x65, 0x72,
	0x73, 0x18, 0x0a, 0x20, 0x03, 0x28, 0x09, 0x52, 0x0a, 0x64, 0x6e, 0x73, 0x53, 0x65, 0x72, 0x76,
	0x65, 0x72, 0x73, 0x12, 0x1d, 0x0a, 0x0a, 0x64, 0x6e, 0x73, 0x5f, 0x64, 0x6f, 0x6d, 0x61, 0x69,
	0x6e, 0x18, 0x0b, 0x20, 0x01, 0x28, 0x09, 0x52, 0x09, 0x64, 0x6e, 0x73, 0x44, 0x6f, 0x6d, 0x61,
	0x69, 0x6e, 0x12, 0x1f, 0x0a, 0x0b, 0x6e, 0x74, 0x70, 0x5f, 0x73, 0x65, 0x72, 0x76, 0x65, 0x72,
	0x73, 0x18, 0x0c, 0x20, 0x03, 0x28, 0x09, 0x52, 0x0a, 0x6e, 0x74, 0x70, 0x53, 0x65, 0x72, 0x76,
	0x65, 0x72, 0x73, 0x12, 0x10, 0x0a, 0x03, 0x6d, 0x74, 0x75, 0x18, 0x0d, 0x20, 0x01, 0x28, 0x0d,
	0x52, 0x03, 0x6d, 0x74, 0x75, 0x12, 0x45, 0x0a, 0x0c, 0x70, 0x72, 0x6f, 0x78, 0x79, 0x5f, 0x63,
	0x6f, 0x6e, 0x66, 0x69, 0x67, 0x18, 0x0e, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x22, 0x2e, 0x6f, 0x72,
	0x67, 0x2e, 0x6c, 0x66, 0x65, 0x64, 0x67, 0x65, 0x2e, 0x65, 0x76, 0x65, 0x2e, 0x63, 0x6f, 0x6d,
	0x6d, 0x6f, 0x6e, 0x2e, 0x50, 0x72, 0x6f, 0x78, 0x79, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x52,
	0x0b, 0x70, 0x72, 0x6f, 0x78, 0x79, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x12, 0x56, 0x0a, 0x14,
	0x77, 0x69, 0x72, 0x65, 0x6c, 0x65, 0x73, 0x73, 0x5f, 0x64, 0x65, 0x76, 0x69, 0x63, 0x65, 0x5f,
	0x74, 0x79, 0x70, 0x65, 0x18, 0x0f, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x24, 0x2e, 0x6f, 0x72, 0x67,
	0x2e, 0x6c, 0x66, 0x65, 0x64, 0x67, 0x65, 0x2e, 0x65, 0x76, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x66,
	0x69, 0x6c, 0x65, 0x2e, 0x57, 0x69, 0x72, 0x65, 0x6c, 0x65, 0x73, 0x73, 0x54, 0x79, 0x70, 0x65,
	0x52, 0x12, 0x77, 0x69, 0x72, 0x65, 0x6c, 0x65, 0x73, 0x73, 0x44, 0x65, 0x76, 0x69, 0x63, 0x65,
	0x54, 0x79, 0x70, 0x65, 0x12, 0x51, 0x0a, 0x0f, 0x63, 0x65, 0x6c, 0x6c, 0x75, 0x6c, 0x61, 0x72,
	0x5f, 0x63, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x18, 0x10, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x26, 0x2e,
	0x6f, 0x72, 0x67, 0x2e, 0x6c, 0x66, 0x65, 0x64, 0x67, 0x65, 0x2e, 0x65, 0x76, 0x65, 0x2e, 0x70,
	0x72, 0x6f, 0x66, 0x69, 0x6c, 0x65, 0x2e, 0x43, 0x65, 0x6c, 0x6c, 0x75, 0x6c, 0x61, 0x72, 0x43,
	0x6f, 0x6e, 0x66, 0x69, 0x67, 0x48, 0x00, 0x52, 0x0e, 0x63, 0x65, 0x6c, 0x6c, 0x75, 0x6c, 0x61,
	0x72, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x12, 0x45, 0x0a, 0x0b, 0x77, 0x69, 0x66, 0x69, 0x5f,
	0x63, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x18, 0x11, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x22, 0x2e, 0x6f,
	0x72, 0x67, 0x2e, 0x6c, 0x66, 0x65, 0x64, 0x67, 0x65, 0x2e, 0x65, 0x76, 0x65, 0x2e, 0x70, 0x72,
	0x6f, 0x66, 0x69, 0x6c, 0x65, 0x2e, 0x57, 0x69, 0x66, 0x69, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67,
	0x48, 0x00, 0x52, 0x0a, 0x77, 0x69, 0x66, 0x69, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x12, 0x23,
	0x0a, 0x0d, 0x65, 0x72, 0x72, 0x6f, 0x72, 0x5f, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x18,
	0x14, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0c, 0x65, 0x72, 0x72, 0x6f, 0x72, 0x4d, 0x65, 0x73, 0x73,
	0x61, 0x67, 0x65, 0x42, 0x11, 0x0a, 0x0f, 0x77, 0x69, 0x72, 0x65, 0x6c, 0x65, 0x73, 0x73, 0x5f,
	0x63, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x22, 0xdb, 0x03, 0x0a, 0x0e, 0x43, 0x65, 0x6c, 0x6c, 0x75,
	0x6c, 0x61, 0x72, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x12, 0x10, 0x0a, 0x03, 0x61, 0x70, 0x6e,
	0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x03, 0x61, 0x70, 0x6e, 0x12, 0x1d, 0x0a, 0x0a, 0x61,
	0x74, 0x74, 0x61, 0x63, 0x68, 0x5f, 0x61, 0x70, 0x6e, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52,
	0x09, 0x61, 0x74, 0x74, 0x61, 0x63, 0x68, 0x41, 0x70, 0x6e, 0x12, 0x3e, 0x0a, 0x07, 0x69, 0x70,
	0x5f, 0x74, 0x79, 0x70, 0x65, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x25, 0x2e, 0x6f, 0x72,
	0x67, 0x2e, 0x6c, 0x66, 0x65, 0x64, 0x67, 0x65, 0x2e, 0x65, 0x76, 0x65, 0x2e, 0x63, 0x6f, 0x6d,
	0x6d, 0x6f, 0x6e, 0x2e, 0x43, 0x65, 0x6c, 0x6c, 0x75, 0x6c, 0x61, 0x72, 0x49, 0x50, 0x54, 0x79,
	0x70, 0x65, 0x52, 0x06, 0x69, 0x70, 0x54, 0x79, 0x70, 0x65, 0x12, 0x4b, 0x0a, 0x0e, 0x61, 0x74,
	0x74, 0x61, 0x63, 0x68, 0x5f, 0x69, 0x70, 0x5f, 0x74, 0x79, 0x70, 0x65, 0x18, 0x04, 0x20, 0x01,
	0x28, 0x0e, 0x32, 0x25, 0x2e, 0x6f, 0x72, 0x67, 0x2e, 0x6c, 0x66, 0x65, 0x64, 0x67, 0x65, 0x2e,
	0x65, 0x76, 0x65, 0x2e, 0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2e, 0x43, 0x65, 0x6c, 0x6c, 0x75,
	0x6c, 0x61, 0x72, 0x49, 0x50, 0x54, 0x79, 0x70, 0x65, 0x52, 0x0c, 0x61, 0x74, 0x74, 0x61, 0x63,
	0x68, 0x49, 0x70, 0x54, 0x79, 0x70, 0x65, 0x12, 0x2a, 0x0a, 0x11, 0x61, 0x63, 0x74, 0x69, 0x76,
	0x61, 0x74, 0x65, 0x5f, 0x73, 0x69, 0x6d, 0x5f, 0x73, 0x6c, 0x6f, 0x74, 0x18, 0x05, 0x20, 0x01,
	0x28, 0x0d, 0x52, 0x0f, 0x61, 0x63, 0x74, 0x69, 0x76, 0x61, 0x74, 0x65, 0x53, 0x69, 0x6d, 0x53,
	0x6c, 0x6f, 0x74, 0x12, 0x27, 0x0a, 0x0f, 0x64, 0x69, 0x73, 0x61, 0x62, 0x6c, 0x65, 0x5f, 0x72,
	0x6f, 0x61, 0x6d, 0x69, 0x6e, 0x67, 0x18, 0x06, 0x20, 0x01, 0x28, 0x08, 0x52, 0x0e, 0x64, 0x69,
	0x73, 0x61, 0x62, 0x6c, 0x65, 0x52, 0x6f, 0x61, 0x6d, 0x69, 0x6e, 0x67, 0x12, 0x5b, 0x0a, 0x13,
	0x64, 0x65, 0x66, 0x61, 0x75, 0x6c, 0x74, 0x5f, 0x62, 0x65, 0x61, 0x72, 0x65, 0x72, 0x5f, 0x61,
	0x75, 0x74, 0x68, 0x18, 0x07, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x2b, 0x2e, 0x6f, 0x72, 0x67, 0x2e,
	0x6c, 0x66, 0x65, 0x64, 0x67, 0x65, 0x2e, 0x65, 0x76, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x66, 0x69,
	0x6c, 0x65, 0x2e, 0x43, 0x65, 0x6c, 0x6c, 0x75, 0x6c, 0x61, 0x72, 0x4e, 0x65, 0x74, 0x77, 0x6f,
	0x72, 0x6b, 0x41, 0x75, 0x74, 0x68, 0x52, 0x11, 0x64, 0x65, 0x66, 0x61, 0x75, 0x6c, 0x74, 0x42,
	0x65, 0x61, 0x72, 0x65, 0x72, 0x41, 0x75, 0x74, 0x68, 0x12, 0x59, 0x0a, 0x12, 0x61, 0x74, 0x74,
	0x61, 0x63, 0x68, 0x5f, 0x62, 0x65, 0x61, 0x72, 0x65, 0x72, 0x5f, 0x61, 0x75, 0x74, 0x68, 0x18,
	0x08, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x2b, 0x2e, 0x6f, 0x72, 0x67, 0x2e, 0x6c, 0x66, 0x65, 0x64,
	0x67, 0x65, 0x2e, 0x65, 0x76, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x66, 0x69, 0x6c, 0x65, 0x2e, 0x43,
	0x65, 0x6c, 0x6c, 0x75, 0x6c, 0x61, 0x72, 0x4e, 0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b, 0x41, 0x75,
	0x74, 0x68, 0x52, 0x10, 0x61, 0x74, 0x74, 0x61, 0x63, 0x68, 0x42, 0x65, 0x61, 0x72, 0x65, 0x72,
	0x41, 0x75, 0x74, 0x68, 0x22, 0x9f, 0x01, 0x0a, 0x13, 0x43, 0x65, 0x6c, 0x6c, 0x75, 0x6c, 0x61,
	0x72, 0x4e, 0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b, 0x41, 0x75, 0x74, 0x68, 0x12, 0x50, 0x0a, 0x0d,
	0x61, 0x75, 0x74, 0x68, 0x5f, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x6f, 0x6c, 0x18, 0x01, 0x20,
	0x01, 0x28, 0x0e, 0x32, 0x2b, 0x2e, 0x6f, 0x72, 0x67, 0x2e, 0x6c, 0x66, 0x65, 0x64, 0x67, 0x65,
	0x2e, 0x65, 0x76, 0x65, 0x2e, 0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2e, 0x43, 0x65, 0x6c, 0x6c,
	0x75, 0x6c, 0x61, 0x72, 0x41, 0x75, 0x74, 0x68, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x6f, 0x6c,
	0x52, 0x0c, 0x61, 0x75, 0x74, 0x68, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x6f, 0x6c, 0x12, 0x1a,
	0x0a, 0x08, 0x75, 0x73, 0x65, 0x72, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09,
	0x52, 0x08, 0x75, 0x73, 0x65, 0x72, 0x6e, 0x61, 0x6d, 0x65, 0x12, 0x1a, 0x0a, 0x08, 0x70, 0x61,
	0x73, 0x73, 0x77, 0x6f, 0x72, 0x64, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x52, 0x08, 0x70, 0x61,
	0x73, 0x73, 0x77, 0x6f, 0x72, 0x64, 0x22, 0x9d, 0x01, 0x0a, 0x0a, 0x57, 0x69, 0x66, 0x69, 0x43,
	0x6f, 0x6e, 0x66, 0x69, 0x67, 0x12, 0x12, 0x0a, 0x04, 0x73, 0x73, 0x69, 0x64, 0x18, 0x01, 0x20,
	0x01, 0x28, 0x09, 0x52, 0x04, 0x73, 0x73, 0x69, 0x64, 0x12, 0x43, 0x0a, 0x0a, 0x6b, 0x65, 0x79,
	0x5f, 0x73, 0x63, 0x68, 0x65, 0x6d, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x24, 0x2e,
	0x6f, 0x72, 0x67, 0x2e, 0x6c, 0x66, 0x65, 0x64, 0x67, 0x65, 0x2e, 0x65, 0x76, 0x65, 0x2e, 0x63,
	0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2e, 0x57, 0x69, 0x46, 0x69, 0x4b, 0x65, 0x79, 0x53, 0x63, 0x68,
	0x65, 0x6d, 0x65, 0x52, 0x09, 0x6b, 0x65, 0x79, 0x53, 0x63, 0x68, 0x65, 0x6d, 0x65, 0x12, 0x1a,
	0x0a, 0x08, 0x69, 0x64, 0x65, 0x6e, 0x74, 0x69, 0x74, 0x79, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09,
	0x52, 0x08, 0x69, 0x64, 0x65, 0x6e, 0x74, 0x69, 0x74, 0x79, 0x12, 0x1a, 0x0a, 0x08, 0x70, 0x61,
	0x73, 0x73, 0x77, 0x6f, 0x72, 0x64, 0x18, 0x04, 0x20, 0x01, 0x28, 0x09, 0x52, 0x08, 0x70, 0x61,
	0x73, 0x73, 0x77, 0x6f, 0x72, 0x64, 0x2a, 0xb2, 0x01, 0x0a, 0x0c, 0x43, 0x6f, 0x6e, 0x66, 0x69,
	0x67, 0x53, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x12, 0x1d, 0x0a, 0x19, 0x43, 0x4f, 0x4e, 0x46, 0x49,
	0x47, 0x5f, 0x53, 0x4f, 0x55, 0x52, 0x43, 0x45, 0x5f, 0x55, 0x4e, 0x53, 0x50, 0x45, 0x43, 0x49,
	0x46, 0x49, 0x45, 0x44, 0x10, 0x00, 0x12, 0x1c, 0x0a, 0x18, 0x43, 0x4f, 0x4e, 0x46, 0x49, 0x47,
	0x5f, 0x53, 0x4f, 0x55, 0x52, 0x43, 0x45, 0x5f, 0x43, 0x4f, 0x4e, 0x54, 0x52, 0x4f, 0x4c, 0x4c,
	0x45, 0x52, 0x10, 0x01, 0x12, 0x1b, 0x0a, 0x17, 0x43, 0x4f, 0x4e, 0x46, 0x49, 0x47, 0x5f, 0x53,
	0x4f, 0x55, 0x52, 0x43, 0x45, 0x5f, 0x42, 0x4f, 0x4f, 0x54, 0x53, 0x54, 0x52, 0x41, 0x50, 0x10,
	0x02, 0x12, 0x1a, 0x0a, 0x16, 0x43, 0x4f, 0x4e, 0x46, 0x49, 0x47, 0x5f, 0x53, 0x4f, 0x55, 0x52,
	0x43, 0x45, 0x5f, 0x4f, 0x56, 0x45, 0x52, 0x52, 0x49, 0x44, 0x45, 0x10, 0x03, 0x12, 0x15, 0x0a,
	0x11, 0x43, 0x4f, 0x4e, 0x46, 0x49, 0x47, 0x5f, 0x53, 0x4f, 0x55, 0x52, 0x43, 0x45, 0x5f, 0x4c,
	0x4f, 0x43, 0x10, 0x04, 0x12, 0x15, 0x0a, 0x11, 0x43, 0x4f, 0x4e, 0x46, 0x49, 0x47, 0x5f, 0x53,
	0x4f, 0x55, 0x52, 0x43, 0x45, 0x5f, 0x4c, 0x50, 0x53, 0x10, 0x05, 0x2a, 0x76, 0x0a, 0x09, 0x49,
	0x50, 0x56, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x12, 0x1a, 0x0a, 0x16, 0x49, 0x50, 0x5f, 0x56,
	0x45, 0x52, 0x53, 0x49, 0x4f, 0x4e, 0x5f, 0x55, 0x4e, 0x53, 0x50, 0x45, 0x43, 0x49, 0x46, 0x49,
	0x45, 0x44, 0x10, 0x00, 0x12, 0x19, 0x0a, 0x15, 0x49, 0x50, 0x5f, 0x56, 0x45, 0x52, 0x53, 0x49,
	0x4f, 0x4e, 0x5f, 0x44, 0x55, 0x41, 0x4c, 0x5f, 0x53, 0x54, 0x41, 0x43, 0x4b, 0x10, 0x01, 0x12,
	0x18, 0x0a, 0x14, 0x49, 0x50, 0x5f, 0x56, 0x45, 0x52, 0x53, 0x49, 0x4f, 0x4e, 0x5f, 0x49, 0x50,
	0x56, 0x34, 0x5f, 0x4f, 0x4e, 0x4c, 0x59, 0x10, 0x02, 0x12, 0x18, 0x0a, 0x14, 0x49, 0x50, 0x5f,
	0x56, 0x45, 0x52, 0x53, 0x49, 0x4f, 0x4e, 0x5f, 0x49, 0x50, 0x56, 0x36, 0x5f, 0x4f, 0x4e, 0x4c,
	0x59, 0x10, 0x03, 0x2a, 0x61, 0x0a, 0x0c, 0x57, 0x69, 0x72, 0x65, 0x6c, 0x65, 0x73, 0x73, 0x54,
	0x79, 0x70, 0x65, 0x12, 0x1d, 0x0a, 0x19, 0x57, 0x49, 0x52, 0x45, 0x4c, 0x45, 0x53, 0x53, 0x5f,
	0x54, 0x59, 0x50, 0x45, 0x5f, 0x55, 0x4e, 0x53, 0x50, 0x45, 0x43, 0x49, 0x46, 0x49, 0x45, 0x44,
	0x10, 0x00, 0x12, 0x1a, 0x0a, 0x16, 0x57, 0x49, 0x52, 0x45, 0x4c, 0x45, 0x53, 0x53, 0x5f, 0x54,
	0x59, 0x50, 0x45, 0x5f, 0x43, 0x45, 0x4c, 0x4c, 0x55, 0x4c, 0x41, 0x52, 0x10, 0x01, 0x12, 0x16,
	0x0a, 0x12, 0x57, 0x49, 0x52, 0x45, 0x4c, 0x45, 0x53, 0x53, 0x5f, 0x54, 0x59, 0x50, 0x45, 0x5f,
	0x57, 0x49, 0x46, 0x49, 0x10, 0x02, 0x42, 0x3f, 0x0a, 0x16, 0x6f, 0x72, 0x67, 0x2e, 0x6c, 0x66,
	0x65, 0x64, 0x67, 0x65, 0x2e, 0x65, 0x76, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x66, 0x69, 0x6c, 0x65,
	0x5a, 0x25, 0x67, 0x69, 0x74, 0x68, 0x75, 0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x6c, 0x66, 0x2d,
	0x65, 0x64, 0x67, 0x65, 0x2f, 0x65, 0x76, 0x65, 0x2d, 0x61, 0x70, 0x69, 0x2f, 0x67, 0x6f, 0x2f,
	0x70, 0x72, 0x6f, 0x66, 0x69, 0x6c, 0x65, 0x62, 0x06, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x33,
}

var (
	file_profile_network_proto_rawDescOnce sync.Once
	file_profile_network_proto_rawDescData = file_profile_network_proto_rawDesc
)

func file_profile_network_proto_rawDescGZIP() []byte {
	file_profile_network_proto_rawDescOnce.Do(func() {
		file_profile_network_proto_rawDescData = protoimpl.X.CompressGZIP(file_profile_network_proto_rawDescData)
	})
	return file_profile_network_proto_rawDescData
}

var file_profile_network_proto_enumTypes = make([]protoimpl.EnumInfo, 3)
var file_profile_network_proto_msgTypes = make([]protoimpl.MessageInfo, 9)
var file_profile_network_proto_goTypes = []interface{}{
	(ConfigSource)(0),                   // 0: org.lfedge.eve.profile.ConfigSource
	(IPVersion)(0),                      // 1: org.lfedge.eve.profile.IPVersion
	(WirelessType)(0),                   // 2: org.lfedge.eve.profile.WirelessType
	(*NetworkInfo)(nil),                 // 3: org.lfedge.eve.profile.NetworkInfo
	(*NetworkConfigTestingStatus)(nil),  // 4: org.lfedge.eve.profile.NetworkConfigTestingStatus
	(*NetworkConfigChange)(nil),         // 5: org.lfedge.eve.profile.NetworkConfigChange
	(*NetworkConfig)(nil),               // 6: org.lfedge.eve.profile.NetworkConfig
	(*NetworkPortAddresses)(nil),        // 7: org.lfedge.eve.profile.NetworkPortAddresses
	(*NetworkPortConfig)(nil),           // 8: org.lfedge.eve.profile.NetworkPortConfig
	(*CellularConfig)(nil),              // 9: org.lfedge.eve.profile.CellularConfig
	(*CellularNetworkAuth)(nil),         // 10: org.lfedge.eve.profile.CellularNetworkAuth
	(*WifiConfig)(nil),                  // 11: org.lfedge.eve.profile.WifiConfig
	(*timestamppb.Timestamp)(nil),       // 12: google.protobuf.Timestamp
	(*evecommon.DhcpOptionsIgnore)(nil), // 13: org.lfedge.eve.common.DhcpOptionsIgnore
	(*evecommon.ProxyConfig)(nil),       // 14: org.lfedge.eve.common.ProxyConfig
	(evecommon.CellularIPType)(0),       // 15: org.lfedge.eve.common.CellularIPType
	(evecommon.CellularAuthProtocol)(0), // 16: org.lfedge.eve.common.CellularAuthProtocol
	(evecommon.WiFiKeyScheme)(0),        // 17: org.lfedge.eve.common.WiFiKeyScheme
}
var file_profile_network_proto_depIdxs = []int32{
	6,  // 0: org.lfedge.eve.profile.NetworkInfo.latest_config:type_name -> org.lfedge.eve.profile.NetworkConfig
	4,  // 1: org.lfedge.eve.profile.NetworkInfo.config_testing:type_name -> org.lfedge.eve.profile.NetworkConfigTestingStatus
	6,  // 2: org.lfedge.eve.profile.NetworkInfo.fallback_config:type_name -> org.lfedge.eve.profile.NetworkConfig
	6,  // 3: org.lfedge.eve.profile.NetworkInfo.local_changes:type_name -> org.lfedge.eve.profile.NetworkConfig
	12, // 4: org.lfedge.eve.profile.NetworkConfigTestingStatus.last_test_time:type_name -> google.protobuf.Timestamp
	6,  // 5: org.lfedge.eve.profile.NetworkConfigChange.config_changes:type_name -> org.lfedge.eve.profile.NetworkConfig
	8,  // 6: org.lfedge.eve.profile.NetworkConfig.ports:type_name -> org.lfedge.eve.profile.NetworkPortConfig
	0,  // 7: org.lfedge.eve.profile.NetworkConfig.config_source:type_name -> org.lfedge.eve.profile.ConfigSource
	12, // 8: org.lfedge.eve.profile.NetworkConfig.submitted_at:type_name -> google.protobuf.Timestamp
	7,  // 9: org.lfedge.eve.profile.NetworkPortConfig.port_addresses:type_name -> org.lfedge.eve.profile.NetworkPortAddresses
	1,  // 10: org.lfedge.eve.profile.NetworkPortConfig.ip_version:type_name -> org.lfedge.eve.profile.IPVersion
	13, // 11: org.lfedge.eve.profile.NetworkPortConfig.dhcp_options_ignore:type_name -> org.lfedge.eve.common.DhcpOptionsIgnore
	14, // 12: org.lfedge.eve.profile.NetworkPortConfig.proxy_config:type_name -> org.lfedge.eve.common.ProxyConfig
	2,  // 13: org.lfedge.eve.profile.NetworkPortConfig.wireless_device_type:type_name -> org.lfedge.eve.profile.WirelessType
	9,  // 14: org.lfedge.eve.profile.NetworkPortConfig.cellular_config:type_name -> org.lfedge.eve.profile.CellularConfig
	11, // 15: org.lfedge.eve.profile.NetworkPortConfig.wifi_config:type_name -> org.lfedge.eve.profile.WifiConfig
	15, // 16: org.lfedge.eve.profile.CellularConfig.ip_type:type_name -> org.lfedge.eve.common.CellularIPType
	15, // 17: org.lfedge.eve.profile.CellularConfig.attach_ip_type:type_name -> org.lfedge.eve.common.CellularIPType
	10, // 18: org.lfedge.eve.profile.CellularConfig.default_bearer_auth:type_name -> org.lfedge.eve.profile.CellularNetworkAuth
	10, // 19: org.lfedge.eve.profile.CellularConfig.attach_bearer_auth:type_name -> org.lfedge.eve.profile.CellularNetworkAuth
	16, // 20: org.lfedge.eve.profile.CellularNetworkAuth.auth_protocol:type_name -> org.lfedge.eve.common.CellularAuthProtocol
	17, // 21: org.lfedge.eve.profile.WifiConfig.key_scheme:type_name -> org.lfedge.eve.common.WiFiKeyScheme
	22, // [22:22] is the sub-list for method output_type
	22, // [22:22] is the sub-list for method input_type
	22, // [22:22] is the sub-list for extension type_name
	22, // [22:22] is the sub-list for extension extendee
	0,  // [0:22] is the sub-list for field type_name
}

func init() { file_profile_network_proto_init() }
func file_profile_network_proto_init() {
	if File_profile_network_proto != nil {
		return
	}
	if !protoimpl.UnsafeEnabled {
		file_profile_network_proto_msgTypes[0].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*NetworkInfo); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_profile_network_proto_msgTypes[1].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*NetworkConfigTestingStatus); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_profile_network_proto_msgTypes[2].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*NetworkConfigChange); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_profile_network_proto_msgTypes[3].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*NetworkConfig); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_profile_network_proto_msgTypes[4].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*NetworkPortAddresses); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_profile_network_proto_msgTypes[5].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*NetworkPortConfig); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_profile_network_proto_msgTypes[6].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*CellularConfig); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_profile_network_proto_msgTypes[7].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*CellularNetworkAuth); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_profile_network_proto_msgTypes[8].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*WifiConfig); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
	}
	file_profile_network_proto_msgTypes[5].OneofWrappers = []interface{}{
		(*NetworkPortConfig_CellularConfig)(nil),
		(*NetworkPortConfig_WifiConfig)(nil),
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: file_profile_network_proto_rawDesc,
			NumEnums:      3,
			NumMessages:   9,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_profile_network_proto_goTypes,
		DependencyIndexes: file_profile_network_proto_depIdxs,
		EnumInfos:         file_profile_network_proto_enumTypes,
		MessageInfos:      file_profile_network_proto_msgTypes,
	}.Build()
	File_profile_network_proto = out.File
	file_profile_network_proto_rawDesc = nil
	file_profile_network_proto_goTypes = nil
	file_profile_network_proto_depIdxs = nil
}
