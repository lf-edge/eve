// Code generated by protoc-gen-go. DO NOT EDIT.
// source: netcmn.proto

package zconfig

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type ProxyProto int32

const (
	ProxyProto_PROXY_HTTP  ProxyProto = 0
	ProxyProto_PROXY_HTTPS ProxyProto = 1
	ProxyProto_PROXY_SOCKS ProxyProto = 2
	ProxyProto_PROXY_FTP   ProxyProto = 3
	ProxyProto_PROXY_OTHER ProxyProto = 255
)

var ProxyProto_name = map[int32]string{
	0:   "PROXY_HTTP",
	1:   "PROXY_HTTPS",
	2:   "PROXY_SOCKS",
	3:   "PROXY_FTP",
	255: "PROXY_OTHER",
}
var ProxyProto_value = map[string]int32{
	"PROXY_HTTP":  0,
	"PROXY_HTTPS": 1,
	"PROXY_SOCKS": 2,
	"PROXY_FTP":   3,
	"PROXY_OTHER": 255,
}

func (x ProxyProto) String() string {
	return proto.EnumName(ProxyProto_name, int32(x))
}
func (ProxyProto) EnumDescriptor() ([]byte, []int) { return fileDescriptor8, []int{0} }

type DHCPType int32

const (
	DHCPType_DHCPNoop DHCPType = 0
	// used for device adapter
	DHCPType_Static DHCPType = 1
	// used for application simulation
	DHCPType_PassThrough DHCPType = 2
	// used for application simulation
	DHCPType_Server DHCPType = 3
	// used for device adapter
	DHCPType_Client DHCPType = 4
)

var DHCPType_name = map[int32]string{
	0: "DHCPNoop",
	1: "Static",
	2: "PassThrough",
	3: "Server",
	4: "Client",
}
var DHCPType_value = map[string]int32{
	"DHCPNoop":    0,
	"Static":      1,
	"PassThrough": 2,
	"Server":      3,
	"Client":      4,
}

func (x DHCPType) String() string {
	return proto.EnumName(DHCPType_name, int32(x))
}
func (DHCPType) EnumDescriptor() ([]byte, []int) { return fileDescriptor8, []int{1} }

type NetworkType int32

const (
	NetworkType_NETWORKTYPENOOP NetworkType = 0
	NetworkType_V4              NetworkType = 4
	NetworkType_V6              NetworkType = 6
	NetworkType_CryptoEID       NetworkType = 14
)

var NetworkType_name = map[int32]string{
	0:  "NETWORKTYPENOOP",
	4:  "V4",
	6:  "V6",
	14: "CryptoEID",
}
var NetworkType_value = map[string]int32{
	"NETWORKTYPENOOP": 0,
	"V4":              4,
	"V6":              6,
	"CryptoEID":       14,
}

func (x NetworkType) String() string {
	return proto.EnumName(NetworkType_name, int32(x))
}
func (NetworkType) EnumDescriptor() ([]byte, []int) { return fileDescriptor8, []int{2} }

type IpRange struct {
	Start string `protobuf:"bytes,1,opt,name=start" json:"start,omitempty"`
	End   string `protobuf:"bytes,2,opt,name=end" json:"end,omitempty"`
}

func (m *IpRange) Reset()                    { *m = IpRange{} }
func (m *IpRange) String() string            { return proto.CompactTextString(m) }
func (*IpRange) ProtoMessage()               {}
func (*IpRange) Descriptor() ([]byte, []int) { return fileDescriptor8, []int{0} }

func (m *IpRange) GetStart() string {
	if m != nil {
		return m.Start
	}
	return ""
}

func (m *IpRange) GetEnd() string {
	if m != nil {
		return m.End
	}
	return ""
}

type ProxyServer struct {
	Proto  ProxyProto `protobuf:"varint,1,opt,name=proto,enum=ProxyProto" json:"proto,omitempty"`
	Server string     `protobuf:"bytes,2,opt,name=server" json:"server,omitempty"`
	Port   uint32     `protobuf:"varint,3,opt,name=port" json:"port,omitempty"`
}

func (m *ProxyServer) Reset()                    { *m = ProxyServer{} }
func (m *ProxyServer) String() string            { return proto.CompactTextString(m) }
func (*ProxyServer) ProtoMessage()               {}
func (*ProxyServer) Descriptor() ([]byte, []int) { return fileDescriptor8, []int{1} }

func (m *ProxyServer) GetProto() ProxyProto {
	if m != nil {
		return m.Proto
	}
	return ProxyProto_PROXY_HTTP
}

func (m *ProxyServer) GetServer() string {
	if m != nil {
		return m.Server
	}
	return ""
}

func (m *ProxyServer) GetPort() uint32 {
	if m != nil {
		return m.Port
	}
	return 0
}

type ProxyConfig struct {
	// enable network level proxy in the form of WPAD
	NetworkProxyEnable bool `protobuf:"varint,1,opt,name=networkProxyEnable" json:"networkProxyEnable,omitempty"`
	// dedicated per protocol information
	Proxies []*ProxyServer `protobuf:"bytes,2,rep,name=proxies" json:"proxies,omitempty"`
	// exceptions seperated by commas
	Exceptions string `protobuf:"bytes,3,opt,name=exceptions" json:"exceptions,omitempty"`
	// or pacfile can be in place of others
	// base64 encoded
	Pacfile string `protobuf:"bytes,4,opt,name=pacfile" json:"pacfile,omitempty"`
	// Direct URL for wpad.dat download
	NetworkProxyURL string `protobuf:"bytes,5,opt,name=networkProxyURL" json:"networkProxyURL,omitempty"`
}

func (m *ProxyConfig) Reset()                    { *m = ProxyConfig{} }
func (m *ProxyConfig) String() string            { return proto.CompactTextString(m) }
func (*ProxyConfig) ProtoMessage()               {}
func (*ProxyConfig) Descriptor() ([]byte, []int) { return fileDescriptor8, []int{2} }

func (m *ProxyConfig) GetNetworkProxyEnable() bool {
	if m != nil {
		return m.NetworkProxyEnable
	}
	return false
}

func (m *ProxyConfig) GetProxies() []*ProxyServer {
	if m != nil {
		return m.Proxies
	}
	return nil
}

func (m *ProxyConfig) GetExceptions() string {
	if m != nil {
		return m.Exceptions
	}
	return ""
}

func (m *ProxyConfig) GetPacfile() string {
	if m != nil {
		return m.Pacfile
	}
	return ""
}

func (m *ProxyConfig) GetNetworkProxyURL() string {
	if m != nil {
		return m.NetworkProxyURL
	}
	return ""
}

// These are list of static mapping that can be added to network
type ZnetStaticDNSEntry struct {
	HostName string   `protobuf:"bytes,1,opt,name=HostName" json:"HostName,omitempty"`
	Address  []string `protobuf:"bytes,2,rep,name=Address" json:"Address,omitempty"`
}

func (m *ZnetStaticDNSEntry) Reset()                    { *m = ZnetStaticDNSEntry{} }
func (m *ZnetStaticDNSEntry) String() string            { return proto.CompactTextString(m) }
func (*ZnetStaticDNSEntry) ProtoMessage()               {}
func (*ZnetStaticDNSEntry) Descriptor() ([]byte, []int) { return fileDescriptor8, []int{3} }

func (m *ZnetStaticDNSEntry) GetHostName() string {
	if m != nil {
		return m.HostName
	}
	return ""
}

func (m *ZnetStaticDNSEntry) GetAddress() []string {
	if m != nil {
		return m.Address
	}
	return nil
}

// Common for IPv4 and IPv6
type Ipspec struct {
	Dhcp DHCPType `protobuf:"varint,2,opt,name=dhcp,enum=DHCPType" json:"dhcp,omitempty"`
	// subnet is CIDR format...x.y.z.l/nn
	Subnet  string   `protobuf:"bytes,3,opt,name=subnet" json:"subnet,omitempty"`
	Gateway string   `protobuf:"bytes,5,opt,name=gateway" json:"gateway,omitempty"`
	Domain  string   `protobuf:"bytes,6,opt,name=domain" json:"domain,omitempty"`
	Ntp     string   `protobuf:"bytes,7,opt,name=ntp" json:"ntp,omitempty"`
	Dns     []string `protobuf:"bytes,8,rep,name=dns" json:"dns,omitempty"`
	// for IPAM management when dhcp is turned on.
	// If none provided, system will default pool.
	DhcpRange *IpRange `protobuf:"bytes,9,opt,name=dhcpRange" json:"dhcpRange,omitempty"`
}

func (m *Ipspec) Reset()                    { *m = Ipspec{} }
func (m *Ipspec) String() string            { return proto.CompactTextString(m) }
func (*Ipspec) ProtoMessage()               {}
func (*Ipspec) Descriptor() ([]byte, []int) { return fileDescriptor8, []int{4} }

func (m *Ipspec) GetDhcp() DHCPType {
	if m != nil {
		return m.Dhcp
	}
	return DHCPType_DHCPNoop
}

func (m *Ipspec) GetSubnet() string {
	if m != nil {
		return m.Subnet
	}
	return ""
}

func (m *Ipspec) GetGateway() string {
	if m != nil {
		return m.Gateway
	}
	return ""
}

func (m *Ipspec) GetDomain() string {
	if m != nil {
		return m.Domain
	}
	return ""
}

func (m *Ipspec) GetNtp() string {
	if m != nil {
		return m.Ntp
	}
	return ""
}

func (m *Ipspec) GetDns() []string {
	if m != nil {
		return m.Dns
	}
	return nil
}

func (m *Ipspec) GetDhcpRange() *IpRange {
	if m != nil {
		return m.DhcpRange
	}
	return nil
}

func init() {
	proto.RegisterType((*IpRange)(nil), "ipRange")
	proto.RegisterType((*ProxyServer)(nil), "ProxyServer")
	proto.RegisterType((*ProxyConfig)(nil), "ProxyConfig")
	proto.RegisterType((*ZnetStaticDNSEntry)(nil), "ZnetStaticDNSEntry")
	proto.RegisterType((*Ipspec)(nil), "ipspec")
	proto.RegisterEnum("ProxyProto", ProxyProto_name, ProxyProto_value)
	proto.RegisterEnum("DHCPType", DHCPType_name, DHCPType_value)
	proto.RegisterEnum("NetworkType", NetworkType_name, NetworkType_value)
}

func init() { proto.RegisterFile("netcmn.proto", fileDescriptor8) }

var fileDescriptor8 = []byte{
	// 589 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x6c, 0x53, 0xdf, 0x6f, 0x12, 0x41,
	0x10, 0xee, 0x01, 0x3d, 0xb8, 0xa1, 0xa5, 0x9b, 0xd5, 0x98, 0x8b, 0x49, 0x15, 0x79, 0x68, 0x48,
	0x1f, 0xae, 0x11, 0x8d, 0xcf, 0x56, 0x8a, 0x41, 0xab, 0x70, 0x59, 0xce, 0x1f, 0x6d, 0x4c, 0x9a,
	0xe5, 0x6e, 0x0b, 0x1b, 0x61, 0x77, 0x73, 0xb7, 0xd8, 0xd2, 0xff, 0xcd, 0x3f, 0xc0, 0xbf, 0x4a,
	0xb3, 0xbb, 0x87, 0x34, 0xc6, 0x27, 0xe6, 0xfb, 0x66, 0xf6, 0x9b, 0x8f, 0x99, 0x39, 0xd8, 0x13,
	0x4c, 0xa7, 0x4b, 0x11, 0xa9, 0x5c, 0x6a, 0xd9, 0x79, 0x0e, 0x75, 0xae, 0x08, 0x15, 0x33, 0x86,
	0x1f, 0xc2, 0x6e, 0xa1, 0x69, 0xae, 0x43, 0xaf, 0xed, 0x75, 0x03, 0xe2, 0x00, 0x46, 0x50, 0x65,
	0x22, 0x0b, 0x2b, 0x96, 0x33, 0x61, 0xe7, 0x1b, 0x34, 0xe3, 0x5c, 0xde, 0xae, 0x27, 0x2c, 0xff,
	0xc1, 0x72, 0xfc, 0x0c, 0x76, 0xad, 0x94, 0x7d, 0xd6, 0xea, 0x35, 0x8d, 0xf0, 0xed, 0x3a, 0x36,
	0x14, 0x71, 0x19, 0xfc, 0x08, 0xfc, 0xc2, 0x16, 0x97, 0x32, 0x25, 0xc2, 0x18, 0x6a, 0x4a, 0xe6,
	0x3a, 0xac, 0xb6, 0xbd, 0xee, 0x3e, 0xb1, 0x71, 0xe7, 0x97, 0x57, 0xca, 0xf7, 0xa5, 0xb8, 0xe6,
	0x33, 0x1c, 0x01, 0x16, 0x4c, 0xdf, 0xc8, 0xfc, 0xbb, 0x65, 0x07, 0x82, 0x4e, 0x17, 0xcc, 0xf6,
	0x6a, 0x90, 0xff, 0x64, 0xf0, 0x11, 0xd4, 0x8d, 0x01, 0xce, 0x8a, 0xb0, 0xd2, 0xae, 0x76, 0x9b,
	0xbd, 0xbd, 0xe8, 0x9e, 0x5b, 0xb2, 0x49, 0xe2, 0x27, 0x00, 0xec, 0x36, 0x65, 0x4a, 0x73, 0x29,
	0x0a, 0xeb, 0x20, 0x20, 0xf7, 0x18, 0x1c, 0x42, 0x5d, 0xd1, 0xf4, 0x9a, 0x2f, 0x58, 0x58, 0xb3,
	0xc9, 0x0d, 0xc4, 0x5d, 0x38, 0xb8, 0xdf, 0xf7, 0x13, 0xf9, 0x10, 0xee, 0xda, 0x8a, 0x7f, 0xe9,
	0xce, 0x7b, 0xc0, 0x97, 0x82, 0xe9, 0x89, 0xa6, 0x9a, 0xa7, 0x67, 0xa3, 0xc9, 0x40, 0xe8, 0x7c,
	0x8d, 0x1f, 0x43, 0x63, 0x28, 0x0b, 0x3d, 0xa2, 0x4b, 0x56, 0x8e, 0xfa, 0x2f, 0x36, 0x5d, 0x4f,
	0xb3, 0x2c, 0x67, 0x85, 0x73, 0x1f, 0x90, 0x0d, 0xec, 0xfc, 0xf4, 0xc0, 0xe7, 0xaa, 0x50, 0x2c,
	0xc5, 0x87, 0x50, 0xcb, 0xe6, 0xa9, 0xb2, 0xc3, 0x6c, 0xf5, 0x82, 0xe8, 0x6c, 0xd8, 0x8f, 0x93,
	0xb5, 0x62, 0xc4, 0xd2, 0x76, 0xda, 0xab, 0xa9, 0x60, 0xba, 0xfc, 0x57, 0x25, 0x32, 0xda, 0x33,
	0xaa, 0xd9, 0x0d, 0x5d, 0x97, 0x7e, 0x37, 0xd0, 0xbc, 0xc8, 0xe4, 0x92, 0x72, 0x11, 0xfa, 0xee,
	0x85, 0x43, 0x66, 0xf7, 0x42, 0xab, 0xb0, 0xee, 0x76, 0x2f, 0xb4, 0x32, 0x4c, 0x26, 0x8a, 0xb0,
	0x61, 0xbd, 0x99, 0x10, 0x1f, 0x41, 0x60, 0xba, 0xda, 0x13, 0x0a, 0x83, 0xb6, 0xd7, 0x6d, 0xf6,
	0x1a, 0x51, 0x79, 0x52, 0x64, 0x9b, 0x3a, 0xbe, 0x02, 0xd8, 0x1e, 0x06, 0x6e, 0x01, 0xc4, 0x64,
	0xfc, 0xf5, 0xe2, 0x6a, 0x98, 0x24, 0x31, 0xda, 0xc1, 0x07, 0xd0, 0xdc, 0xe2, 0x09, 0xf2, 0xb6,
	0xc4, 0x64, 0xdc, 0x3f, 0x9f, 0xa0, 0x0a, 0xde, 0x87, 0xc0, 0x11, 0x6f, 0x93, 0x18, 0x55, 0x31,
	0xda, 0xe4, 0xc7, 0xc9, 0x70, 0x40, 0xd0, 0x6f, 0xef, 0xf8, 0x23, 0x34, 0x36, 0x83, 0xc0, 0x7b,
	0x2e, 0x1e, 0x49, 0xa9, 0xd0, 0x0e, 0x06, 0xf0, 0xdd, 0x0a, 0x4a, 0x5d, 0x5a, 0x14, 0xc9, 0x3c,
	0x97, 0xab, 0xd9, 0x1c, 0x55, 0x6c, 0xd2, 0x9e, 0x06, 0xaa, 0x9a, 0xb8, 0xbf, 0xe0, 0x4c, 0x68,
	0x54, 0x3b, 0x3e, 0x85, 0xe6, 0xc8, 0xad, 0xd3, 0x2a, 0x3e, 0x80, 0x83, 0xd1, 0x20, 0xf9, 0x32,
	0x26, 0xe7, 0xc9, 0x45, 0x3c, 0x18, 0x8d, 0xc7, 0xc6, 0xb5, 0x0f, 0x95, 0xcf, 0x2f, 0x51, 0xcd,
	0xfe, 0xbe, 0x42, 0xbe, 0xf1, 0xd8, 0xcf, 0xd7, 0x4a, 0xcb, 0xc1, 0xbb, 0x33, 0xd4, 0x7a, 0xf3,
	0x1a, 0x9e, 0xa6, 0x72, 0x19, 0xdd, 0xb1, 0x8c, 0x65, 0x34, 0x4a, 0x17, 0x72, 0x95, 0x45, 0x2b,
	0x73, 0xfa, 0x3c, 0x65, 0xee, 0xf3, 0xbb, 0x3c, 0x9c, 0x71, 0x3d, 0x5f, 0x4d, 0xa3, 0x54, 0x2e,
	0x4f, 0x5c, 0xdd, 0x09, 0x55, 0xfc, 0xe4, 0x2e, 0xb5, 0xc7, 0x3f, 0xf5, 0x6d, 0xd5, 0x8b, 0x3f,
	0x01, 0x00, 0x00, 0xff, 0xff, 0x7f, 0xe6, 0xb1, 0x34, 0xb4, 0x03, 0x00, 0x00,
}
